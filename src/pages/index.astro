---
import { getCollection } from 'astro:content';
import atomConfig from '../atom.config.js';
import { userTweaks } from '../user-tweaks.js';
import { calculateElectronPositions } from '../atom/utils/electronPositioning.js';

// Get all projects and group by domain to create shells dynamically
const projects = await getCollection('projects');
const domains = [...new Set(projects.map(p => p.data.domain))];

// Calculate electron positions for each shell
const electronsByDomain = projects.reduce((acc, project) => {
  if (!acc[project.data.domain]) acc[project.data.domain] = [];
  acc[project.data.domain].push(project);
  return acc;
}, {});
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Atom Portfolio</title>
		<style>
			body {
				margin: 0;
				padding: 0;
				background: #fff;
				font-family: system-ui, sans-serif;
				display: flex;
				justify-content: center;
				align-items: center;
				min-height: 100vh;
			}
			
			.atom-container {
				display: flex;
				justify-content: center;
				align-items: center;
			}
			
			#atom-svg {
				cursor: grab;
			}
			
			.electron {
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div class="atom-container">
			<svg 
				id="atom-svg"
				width={atomConfig.viewport.width} 
				height={atomConfig.viewport.height} 
				viewBox={`0 0 ${atomConfig.viewport.width} ${atomConfig.viewport.height}`}
				xmlns="http://www.w3.org/2000/svg"
			>
				<!-- Nucleus -->
				<circle 
					cx={atomConfig.viewport.centerX}
					cy={atomConfig.viewport.centerY}
					r={atomConfig.nucleus.radius}
					fill="white"
					stroke={atomConfig.nucleus.color}
					stroke-width={atomConfig.nucleus.strokeWidth}
				/>
				<text 
					x={atomConfig.viewport.centerX}
					y={atomConfig.viewport.centerY}
					text-anchor="middle"
					dominant-baseline="middle"
					font-size={atomConfig.nucleus.fontSize}
					font-weight="bold"
					fill={atomConfig.nucleus.color}
				>
					{atomConfig.nucleus.text}
				</text>

				<!-- Orbital Shells -->
				{domains.map((domain, shellIndex) => {
					const shell = atomConfig.shells[shellIndex] || atomConfig.shells[atomConfig.shells.length - 1];
					const electronsInShell = electronsByDomain[domain] || [];
					
					// Random positioning with collision avoidance
					const minDistance = atomConfig.spacing?.minElectronDistance || 60;
					const count = electronsInShell.length;
					
					let electronPositions = [];
					
					if (count === 1) {
						electronPositions = [Math.random() * 360];
					} else if (count > 1) {
						// Generate random positions with minimum distance enforcement
						for (let i = 0; i < count; i++) {
							let attempts = 0;
							let validPosition = false;
							let newAngle;
							
							while (!validPosition && attempts < 100) {
								newAngle = Math.random() * 360;
								validPosition = true;
								
								// Check distance to all existing positions
								for (let existingAngle of electronPositions) {
									const angleDiff = Math.abs(newAngle - existingAngle);
									const minDist = Math.min(angleDiff, 360 - angleDiff); // Handle wrap-around
									
									if (minDist < minDistance) {
										validPosition = false;
										break;
									}
								}
								attempts++;
							}
							
							// If we couldn't find a valid position after many attempts, just place it randomly
							electronPositions.push(newAngle || Math.random() * 360);
						}
					}
					
					
					return (
						<g data-shell={shellIndex} data-domain={domain}>
							<!-- Shell orbit path -->
							<circle 
								class="shell"
								cx={atomConfig.viewport.centerX}
								cy={atomConfig.viewport.centerY}
								r={shell.radius}
								fill="none"
								stroke={shell.color}
								stroke-width={shell.strokeWidth}
								style={`opacity: ${userTweaks.shell.default.opacity}`}
								data-shell-index={shellIndex}
							/>
							
							<!-- Electrons on this shell -->
							{electronsInShell.map((project, electronIndex) => {
								const angleDegrees = electronPositions[electronIndex];
								const angleRadians = (angleDegrees * Math.PI) / 180; // Convert to radians for trig functions
								const x = atomConfig.viewport.centerX + shell.radius * Math.cos(angleRadians);
								const y = atomConfig.viewport.centerY + shell.radius * Math.sin(angleRadians);
								
								return (
									<circle 
										class="electron"
										cx={x}
										cy={y}
										r={atomConfig.electrons.radius}
										fill={atomConfig.electrons.color}
										stroke={atomConfig.electrons.color}
										stroke-width={atomConfig.electrons.strokeWidth}
										data-project={project.slug}
										data-shell={shellIndex}
										data-angle={angleDegrees}
									>
										<title>{project.data.title}</title>
									</circle>
								);
							})}
						</g>
					);
				})}
			</svg>
		</div>

		<script>
			import { gsap } from 'gsap';
			import { OrbitSystem } from '../atom/core/OrbitSystem.js';
			import atomConfig from '../atom.config.js';
			
			// Initialize orbit system when DOM is ready
			document.addEventListener('DOMContentLoaded', () => {
				console.log('Initializing Atom Portfolio...');
				console.log('GSAP version:', gsap.version);
				
				// Minimum distance system is working correctly!
				
				// Create and start orbit system
				const orbitSystem = new OrbitSystem(atomConfig);
				orbitSystem.init();
				orbitSystem.start();
				
				// Add hover effects to electrons (includes shell effects)
				const electrons = document.querySelectorAll('.electron');
				const shells = document.querySelectorAll('.shell');
				
				// Track hover states to prevent conflicts
				const hoverStates = {
					hoveredElectron: null,
					hoveredShell: null,
					shellsInHoverState: new Set(),
					hoverTimeouts: new Map() // Debounce rapid enter/leave events
				};
				
				// Helper function to reset shell and its electrons to default state
				function resetShellToDefault(shellIndex, wasElectronHovered = false) {
					const shell = shells[shellIndex];
					const shellConfig = atomConfig.shells[shellIndex];
					
					console.log(`ðŸ”„ Resetting shell ${shellIndex} to default (wasElectronHovered: ${wasElectronHovered})`);
					
					if (!shell || !shellConfig) return;
					
					// Reset shell appearance
					gsap.to(shell, {
						attr: { 'stroke-width': shellConfig.strokeWidth },
						opacity: shellConfig.defaultOpacity, // Back to original shell opacity
						duration: atomConfig.timing.hoverDuration,
						ease: 'power2.out',
						onComplete: () => console.log(`âœ… Shell ${shellIndex} reset complete`)
					});
					
					// Only resume motion and reset electrons if we were hovering an electron
					if (wasElectronHovered) {
						orbitSystem.resumeShell(shellIndex);
						const allElectrons = document.querySelectorAll(`.electron`);
						allElectrons.forEach(e => {
							gsap.to(e, {
								opacity: 1.0,
								duration: atomConfig.timing.hoverDuration,
								ease: 'power2.out'
							});
						});
					}
					
					hoverStates.shellsInHoverState.delete(shellIndex);
				}
				
				// Helper function to apply shell hover effects
				function applyShellHoverEffects(shellIndex, hoveredElectron = null) {
					const shell = shells[shellIndex];
					const shellConfig = atomConfig.shells[shellIndex];
					
					console.log(`ðŸ“ Applying hover to shell ${shellIndex}:`, {
						shell, 
						shellConfig, 
						hoverStrokeWidth: shellConfig?.hoverStrokeWidth,
						hoverOpacity: shellConfig?.hoverOpacity,
						hoveredElectron: hoveredElectron,
						alreadyHovered: hoverStates.shellsInHoverState.has(shellIndex)
					});
					
					if (!shell || !shellConfig || hoverStates.shellsInHoverState.has(shellIndex)) return;
					
					// Apply shell appearance changes
					gsap.to(shell, {
						attr: { 'stroke-width': shellConfig.hoverStrokeWidth },
						opacity: shellConfig.hoverOpacity,
						duration: atomConfig.timing.hoverDuration,
						ease: 'power2.out',
						onComplete: () => console.log(`âœ… Shell ${shellIndex} hover animation complete`)
					});
					
					// Only pause motion and apply electron effects when hovering a specific electron
					if (hoveredElectron) {
						// Pause electrons motion
						orbitSystem.pauseShell(shellIndex);
						// SPOTLIGHT ALL ELECTRONS ACROSS ALL SHELLS
						const allElectrons = document.querySelectorAll(`.electron`);
						console.log(`Found ${allElectrons.length} total electrons - applying global spotlight effect`);
						allElectrons.forEach(e => {
							if (e === hoveredElectron) {
								// Keep hovered electron at full opacity (spotlight effect)
								console.log(`ðŸŒŸ GLOBAL SPOTLIGHT: Keeping electron at full opacity`, e);
								gsap.to(e, {
									opacity: 1.0,
									duration: atomConfig.timing.hoverDuration,
									ease: 'power2.out'
								});
							} else {
								// Fade ALL other electrons (cross-shell dimming)
								console.log(`ðŸ”… GLOBAL FADE: Setting electron to opacity ${shellConfig.electronHoverOpacity}`, e);
								gsap.to(e, {
									opacity: shellConfig.electronHoverOpacity,
									duration: atomConfig.timing.hoverDuration,
									ease: 'power2.out'
								});
							}
						});
					} else {
						console.log(`âšª Shell ring hover: No electron spotlight effect applied`);
					}
					
					hoverStates.shellsInHoverState.add(shellIndex);
				}
				
				electrons.forEach(electron => {
					const shellIndex = parseInt(electron.dataset.shell);
					
					electron.addEventListener('mouseenter', () => {
						console.log(`ðŸ”´ Electron hover: shell ${shellIndex}`);
						hoverStates.hoveredElectron = electron;
						
						// Apply electron hover effect (grow)
						gsap.to(electron, {
							attr: { r: atomConfig.electrons.hoverRadius },
							duration: atomConfig.timing.hoverDuration,
							ease: 'power2.out'
						});
						
						// Apply shell hover effects with spotlight on this electron
						applyShellHoverEffects(shellIndex, electron);
					});
					
					electron.addEventListener('mouseleave', () => {
						console.log(`ðŸ”µ Electron leave: shell ${shellIndex}`);
						hoverStates.hoveredElectron = null;
						
						// Reset electron size
						gsap.to(electron, {
							attr: { r: atomConfig.electrons.radius },
							duration: atomConfig.timing.hoverDuration,
							ease: 'power2.out'
						});
						
						// Debounced shell reset
						const timeoutId = setTimeout(() => {
							if (hoverStates.hoveredElectron === null && hoverStates.hoveredShell === null) {
								resetShellToDefault(shellIndex, true); // Was electron hovered
							}
							hoverStates.hoverTimeouts.delete(shellIndex);
						}, 50);
						
						hoverStates.hoverTimeouts.set(shellIndex, timeoutId);
					});
				});
				
				// Add hover effects to shells with debouncing
				shells.forEach((shell) => {
					const shellIndex = parseInt(shell.dataset.shellIndex);
					
					shell.addEventListener('mouseenter', () => {
						console.log(`ðŸŸ¡ Shell hover: ${shellIndex}`);
						
						// Clear any pending reset timeout
						if (hoverStates.hoverTimeouts.has(shellIndex)) {
							clearTimeout(hoverStates.hoverTimeouts.get(shellIndex));
							hoverStates.hoverTimeouts.delete(shellIndex);
						}
						
						hoverStates.hoveredShell = shell;
						applyShellHoverEffects(shellIndex, null); // No specific electron to spotlight
					});
					
					shell.addEventListener('mouseleave', () => {
						console.log(`ðŸŸ¢ Shell leave: ${shellIndex}`);
						hoverStates.hoveredShell = null;
						
						// Debounce the reset - wait 50ms to see if we re-enter
						const timeoutId = setTimeout(() => {
							if (hoverStates.hoveredElectron === null && hoverStates.hoveredShell === null) {
								resetShellToDefault(shellIndex, false); // Was NOT electron hovered
							}
							hoverStates.hoverTimeouts.delete(shellIndex);
						}, 50);
						
						hoverStates.hoverTimeouts.set(shellIndex, timeoutId);
					});
				});
				
				// Store reference globally for debugging
				window.orbitSystem = orbitSystem;
				
				console.log('Orbit system started - electrons should be moving around static shells');
				console.log(`Found ${electrons.length} electrons and ${shells.length} shells for hover effects`);
			});
		</script>
	</body>
</html>
