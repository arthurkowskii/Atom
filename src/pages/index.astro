---
import { getCollection } from 'astro:content';
import atomConfig from '../atom.config.js';
import { userTweaks } from '../user-tweaks.js';
import { calculateElectronPositions } from '../atom/utils/electronPositioning.js';

// Get all projects and group by domain to create shells dynamically
const projects = await getCollection('projects');
const domains = [...new Set(projects.map(p => p.data.domain))];

// Calculate electron positions for each shell
const electronsByDomain = projects.reduce((acc, project) => {
  if (!acc[project.data.domain]) acc[project.data.domain] = [];
  acc[project.data.domain].push(project);
  return acc;
}, {});
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Atom Portfolio</title>
		<style>
            body {
                margin: 0;
                padding: 0;
                background: #fff;
                font-family: system-ui, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                overflow: hidden; /* prevent page scroll white borders during drag */
                user-select: none; /* avoid text selection while dragging */
            }
            
            .atom-container {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            
            #atom-svg {
                cursor: grab;
                touch-action: none; /* prevent touch scrolling/zoom white borders */
                will-change: transform;
            }
			
			.electron {
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<div class="atom-container">
			<svg 
				id="atom-svg"
				width={atomConfig.viewport.width} 
				height={atomConfig.viewport.height} 
				viewBox={`0 0 ${atomConfig.viewport.width} ${atomConfig.viewport.height}`}
				xmlns="http://www.w3.org/2000/svg"
			>
				<!-- Nucleus -->
				<circle 
					cx={atomConfig.viewport.centerX}
					cy={atomConfig.viewport.centerY}
					r={atomConfig.nucleus.radius}
					fill="white"
					stroke={atomConfig.nucleus.color}
					stroke-width={atomConfig.nucleus.strokeWidth}
				/>
				<text 
					x={atomConfig.viewport.centerX}
					y={atomConfig.viewport.centerY}
					text-anchor="middle"
					dominant-baseline="middle"
					font-size={atomConfig.nucleus.fontSize}
					font-weight="bold"
					fill={atomConfig.nucleus.color}
				>
					{atomConfig.nucleus.text}
				</text>

				<!-- Orbital Shells -->
				{domains.map((domain, shellIndex) => {
					const shell = atomConfig.shells[shellIndex] || atomConfig.shells[atomConfig.shells.length - 1];
					const electronsInShell = electronsByDomain[domain] || [];
					
					// Random positioning with collision avoidance
					const minDistance = atomConfig.spacing?.minElectronDistance || 60;
					const count = electronsInShell.length;
					
					let electronPositions = [];
					
					if (count === 1) {
						electronPositions = [Math.random() * 360];
					} else if (count > 1) {
						// Generate random positions with minimum distance enforcement
						for (let i = 0; i < count; i++) {
							let attempts = 0;
							let validPosition = false;
							let newAngle;
							
							while (!validPosition && attempts < 100) {
								newAngle = Math.random() * 360;
								validPosition = true;
								
								// Check distance to all existing positions
								for (let existingAngle of electronPositions) {
									const angleDiff = Math.abs(newAngle - existingAngle);
									const minDist = Math.min(angleDiff, 360 - angleDiff); // Handle wrap-around
									
									if (minDist < minDistance) {
										validPosition = false;
										break;
									}
								}
								attempts++;
							}
							
							// If we couldn't find a valid position after many attempts, just place it randomly
							electronPositions.push(newAngle || Math.random() * 360);
						}
					}
					
					
					return (
						<g data-shell={shellIndex} data-domain={domain}>
							<!-- Shell orbit path -->
							<circle 
								class="shell"
								cx={atomConfig.viewport.centerX}
								cy={atomConfig.viewport.centerY}
								r={shell.radius}
								fill="none"
								stroke={shell.color}
								stroke-width={shell.strokeWidth}
								style={`opacity: ${userTweaks.shell.default.opacity}`}
								data-shell-index={shellIndex}
							/>
							
							<!-- Electrons on this shell -->
							{electronsInShell.map((project, electronIndex) => {
								const angleDegrees = electronPositions[electronIndex];
								const angleRadians = (angleDegrees * Math.PI) / 180; // Convert to radians for trig functions
								const x = atomConfig.viewport.centerX + shell.radius * Math.cos(angleRadians);
								const y = atomConfig.viewport.centerY + shell.radius * Math.sin(angleRadians);
								
								return (
									<circle 
										class="electron"
										cx={x}
										cy={y}
										r={atomConfig.electrons.radius}
										fill={atomConfig.electrons.color}
										stroke={atomConfig.electrons.color}
										stroke-width={atomConfig.electrons.strokeWidth}
										data-project={project.slug}
										data-shell={shellIndex}
										data-angle={angleDegrees}
									>
										<title>{project.data.title}</title>
									</circle>
								);
							})}
						</g>
					);
				})}
			</svg>
		</div>

		<script>
			import { gsap } from 'gsap';
			import { Draggable } from 'gsap/Draggable';
			import { OrbitSystem } from '../atom/core/OrbitSystem.js';
			import atomConfig from '../atom.config.js';
			
			// Initialize orbit system when DOM is ready
			document.addEventListener('DOMContentLoaded', () => {
				console.log('Initializing Atom Portfolio...');
				console.log('GSAP version:', gsap.version);
				
				// Minimum distance system is working correctly!
				
				// Create and start orbit system
				const orbitSystem = new OrbitSystem(atomConfig);
				orbitSystem.init();
				orbitSystem.start();

				// Fit SVG to viewport with uniform scale while keeping math consistent
				const svgEl = document.getElementById('atom-svg');
				const baseW = atomConfig.viewport.width;
				const baseH = atomConfig.viewport.height;
				function fitToViewport() {
					const vw = window.innerWidth;
					const vh = window.innerHeight;
					const scale = Math.min(vw / baseW, vh / baseH);
					svgEl.style.transformOrigin = 'center center';
					svgEl.style.transform = `scale(${scale})`;
				}
				fitToViewport();
				window.addEventListener('resize', fitToViewport);
				
				// Register GSAP Draggable
				gsap.registerPlugin(Draggable);

				// Add hover effects to electrons (includes shell effects)
				const electrons = document.querySelectorAll('.electron');
				const shells = document.querySelectorAll('.shell');
				let dragLock = false; // Suppress hover logic while dragging
				
				// IMMEDIATE STATE MANAGER - No timeouts, no race conditions
				const hoverStateManager = {
					currentState: 'none', // 'none' | 'shell-N' | electron reference
					previousState: 'none',
					currentElectron: null, // Store actual electron element reference
					
					setState(newState, electronElement = null) {
						if (this.currentState === newState) return; // No change needed
						
						console.log(`ðŸŽ¯ STATE CHANGE: ${this.currentState} â†’ ${newState}`);
						this.previousState = this.currentState;
						this.currentState = newState;
						this.currentElectron = electronElement;
						this.applyStateChange();
					},
					
              applyStateChange() {
                // Immediately apply all visual changes
                this.exitPreviousState();
                this.enterCurrentState();
              },
					
              exitPreviousState() {
                if (this.previousState === 'none') return;
                
                // KILL ALL EXISTING ANIMATIONS IMMEDIATELY
                gsap.killTweensOf(shells);
                // Do not kill electron tweens; rely on overwrite for smooth transitions
                
                if (this.previousState.startsWith('shell-')) {
                  const shellIndex = parseInt(this.previousState.split('-')[1]);
                  this.resetShellEffects(shellIndex);
                } else if (this.previousState.startsWith('electron-')) {
                  const shellIndex = parseInt(this.previousState.split('-')[1]);
                  this.resetElectronEffects(shellIndex);
                }
              },
              
              enterCurrentState() {
              if (this.currentState === 'none') {
                // Smoothly animate all electrons to baseline; overwrite prevents mid-state glitches
                gsap.to(document.querySelectorAll('.electron'), {
                  opacity: 1.0,
                  attr: { r: atomConfig.electrons.radius },
                  duration: atomConfig.timing.baselineResetDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                return;
              }
                
                if (this.currentState.startsWith('shell-')) {
                  const shellIndex = parseInt(this.currentState.split('-')[1]);
                  // Ensure electrons are at baseline when only shell is hovered
                  gsap.to(document.querySelectorAll('.electron'), {
                    opacity: 1.0,
                    attr: { r: atomConfig.electrons.radius },
                    duration: atomConfig.timing.hoverDuration,
                    ease: 'power2.out',
                    overwrite: 'auto'
                  });
                  this.applyShellEffects(shellIndex);
                } else if (this.currentState.startsWith('electron-')) {
                  const shellIndex = parseInt(this.currentState.split('-')[1]);
                  this.applyElectronEffects(shellIndex, this.currentElectron);
                }
              },
					
              applyShellEffects(shellIndex) {
                const shell = shells[shellIndex];
                const shellConfig = atomConfig.shells[shellIndex];
                if (!shell || !shellConfig) return;
                
                console.log(`ðŸŸ¡ Applying shell ${shellIndex} effects`);
                gsap.to(shell, {
                  attr: { 'stroke-width': shellConfig.hoverStrokeWidth },
                  opacity: shellConfig.hoverOpacity,
                  duration: atomConfig.timing.hoverDuration, // Configurable
                  ease: 'power2.out'
                });
              },
					
              applyElectronEffects(shellIndex, electron) {
                const shell = shells[shellIndex];
                const shellConfig = atomConfig.shells[shellIndex];
                if (!shell || !shellConfig || !electron) return;
                
                console.log(`ðŸ”´ Applying electron effects for shell ${shellIndex}`);
                
                // Apply shell effects
                this.applyShellEffects(shellIndex);
                
                // Electron growth
                gsap.to(electron, {
                  attr: { r: atomConfig.electrons.hoverRadius },
                  duration: atomConfig.timing.hoverDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                
                // Motion pause
                orbitSystem.pauseShell(shellIndex);
                
                // Global spotlight
                const allElectrons = document.querySelectorAll('.electron');
                allElectrons.forEach(e => {
                  if (e === electron) {
                    gsap.to(e, { opacity: 1.0, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
                  } else {
                    gsap.to(e, { opacity: shellConfig.electronHoverOpacity, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
                  }
                });
              },
					
              resetShellEffects(shellIndex) {
                const shell = shells[shellIndex];
                const shellConfig = atomConfig.shells[shellIndex];
                if (!shell || !shellConfig) return;
                
                console.log(`ðŸ”„ Resetting shell ${shellIndex} effects`);
                gsap.to(shell, {
                  attr: { 'stroke-width': shellConfig.strokeWidth },
                  opacity: shellConfig.defaultOpacity,
                  duration: atomConfig.timing.hoverDuration,
                  ease: 'power2.out'
                });
              },
					
              resetElectronEffects(shellIndex) {
                console.log(`ðŸ”„ Resetting electron effects for shell ${shellIndex}`);
                
                // Reset shell
                this.resetShellEffects(shellIndex);
                
                // Resume motion
                orbitSystem.resumeShell(shellIndex);
                
                // Reset all electrons
                const allElectrons = document.querySelectorAll('.electron');
                allElectrons.forEach(e => {
                  gsap.to(e, {
                    attr: { r: atomConfig.electrons.radius },
                    opacity: 1.0,
                    duration: atomConfig.timing.hoverDuration,
                    ease: 'power2.out',
                    overwrite: 'auto'
                  });
                });
              }
				};
				
				
				electrons.forEach((electron, electronIndex) => {
					const shellIndex = parseInt(electron.dataset.shell);
					
					electron.addEventListener('mouseenter', () => {
						if (dragLock) return;
						// Record electron event timing to prevent mousemove conflicts
						lastElectronEventTime = performance.now();
						// Pass the actual electron element to the state manager
						hoverStateManager.setState(`electron-${shellIndex}-${electronIndex}`, electron);
					});
					
					electron.addEventListener('mouseleave', () => {
						if (dragLock) return;
						// Check if we're still in the shell's tolerance zone via distance calculation
						// The mousemove handler will determine the correct next state
						// For now, assume we're leaving completely (will be corrected by mousemove if needed)
						hoverStateManager.setState('none');
					});

					// Minimal drag-and-drop (no tether visuals)
					let pressTime = 0;
					let maxTravel = 0;
					let startX = 0, startY = 0;
					Draggable.create(electron, {
						type: 'x,y',
						onPress: function () {
							dragLock = true;
							pressTime = performance.now();
							startX = parseFloat(gsap.getProperty(electron, 'x')) || 0;
							startY = parseFloat(gsap.getProperty(electron, 'y')) || 0;
							maxTravel = 0;
							// Pause only this electronâ€™s motion
							orbitSystem.pauseElectron(electron);
						},
						onDrag: function () {
							const curX = parseFloat(gsap.getProperty(electron, 'x')) || 0;
							const curY = parseFloat(gsap.getProperty(electron, 'y')) || 0;
							const dx = curX - startX;
							const dy = curY - startY;
							const dist = Math.hypot(dx, dy);
							maxTravel = Math.max(maxTravel, dist);
						},
						onRelease: function () {
							const releaseTime = performance.now();
							const clickThresholdPx = 8;
							const clickThresholdMs = 180;
							const isClick = maxTravel < clickThresholdPx && (releaseTime - pressTime) < clickThresholdMs;
                    const snapBack = () => {
                        const amp = atomConfig.timing.dragElastic?.amplitude ?? 0.8;
                        const per = atomConfig.timing.dragElastic?.period ?? 0.25;
                        const elasticEase = `elastic.out(${amp}, ${per})`;
                        gsap.to(electron, {
                            x: startX,
                            y: startY,
                            duration: atomConfig.timing.dragSnapDuration ?? atomConfig.timing.hoverDuration,
                            ease: elasticEase,
                            onComplete: () => {
                                orbitSystem.resumeElectron(electron);
                                setTimeout(() => { dragLock = false; }, 80);
                            }
                        });
                    };
							// For now, treat both click and drag release as snap-back
							snapBack();
						}
					});
				});
				
				// RAF-THROTTLED HITBOX SYSTEM - Optimized for performance
      const svgContainer = document.getElementById('atom-svg');
      const tolerance = atomConfig.hitbox?.tolerance ?? 15; // pixels - configurable via user-tweaks.js
				
				// Pre-calculate shell boundaries for performance (squared distances avoid Math.sqrt)
				const shellBoundaries = atomConfig.shells.map((shell, shellIndex) => ({
					innerBoundSquared: (shell.radius - tolerance) ** 2,
					outerBoundSquared: (shell.radius + tolerance) ** 2,
					shellIndex: shellIndex
				}));
				
				// RAF throttling variables
				let rafId = null;
				let pendingMousePosition = null;
				let lastElectronEventTime = 0;
				
				// Capture mouse position (high frequency)
				svgContainer.addEventListener('mousemove', (e) => {
					const rect = svgContainer.getBoundingClientRect();
					// Store only the LATEST mouse position (client coords)
					pendingMousePosition = { clientX: e.clientX, clientY: e.clientY, rectLeft: rect.left, rectTop: rect.top, rectWidth: rect.width, rectHeight: rect.height };
					
					// Schedule processing if not already scheduled (throttled to 60fps)
					if (!rafId) {
						rafId = requestAnimationFrame(processMousePosition);
					}
				});
				
				// Process mouse position (60fps max)
				function processMousePosition() {
					if (!pendingMousePosition) {
						rafId = null;
						return;
					}
					
					// Skip hover processing while dragging
					if (dragLock) {
						pendingMousePosition = null;
						rafId = null;
						return;
					}
					
					const rect = svgContainer.getBoundingClientRect();
					const viewW = baseW;
					const viewH = baseH;
					const scaleX = viewW / rect.width;
					const scaleY = viewH / rect.height;
					const mouseX = (pendingMousePosition.clientX - rect.left) * scaleX;
					const mouseY = (pendingMousePosition.clientY - rect.top) * scaleY;
					const centerX = viewW / 2;
					const centerY = viewH / 2;
					
					// Calculate SQUARED distance (faster - no Math.sqrt needed)
					const distanceSquared = (mouseX - centerX) ** 2 + (mouseY - centerY) ** 2;
					
					// Check which shell we're hovering (if any) using squared distances
					let hoveredShellIndex = null;
					for (let boundary of shellBoundaries) {
						if (distanceSquared >= boundary.innerBoundSquared && 
							distanceSquared <= boundary.outerBoundSquared) {
							hoveredShellIndex = boundary.shellIndex;
							console.log(`ðŸŽ¯ HITBOX: Mouse in shell ${hoveredShellIndex} tolerance zone`);
							break; // Exit early when found
						}
					}
					
					// IMMEDIATE STATE CHANGES - No timeouts, no race conditions
					// Check if we should defer to recent electron events (prevents conflicts)
					const timeSinceElectronEvent = performance.now() - lastElectronEventTime;
					const shouldDeferToElectronEvent = timeSinceElectronEvent < 100; // 100ms grace period
					
					if (hoveredShellIndex !== null) {
						// Only update if we're not already in an electron state for this shell
						const currentElectronState = hoverStateManager.currentState.startsWith(`electron-${hoveredShellIndex}-`);
						if (!currentElectronState && !shouldDeferToElectronEvent) {
							hoverStateManager.setState(`shell-${hoveredShellIndex}`);
						}
					} else {
						// Not hovering any shell - go to none state (but respect recent electron events)
						if (!shouldDeferToElectronEvent) {
							hoverStateManager.setState('none');
						}
					}
					
					// Clear for next frame
					pendingMousePosition = null;
					rafId = null;
				}
				
				// Store reference globally for debugging
				window.orbitSystem = orbitSystem;
				
				console.log('ðŸš€ PHASE 1+2 COMPLETE: Immediate State Manager + RAF Throttling');
				console.log(`Found ${electrons.length} electrons and ${shells.length} visual shells`);
				console.log(`ðŸŽ® Optimized hitbox system: Â±${tolerance}px zones, 60fps max, squared distances`);
				console.log('ðŸŽ¯ Features: Animation interruption, no timeouts, no race conditions');
			});
		</script>
	</body>
</html>
