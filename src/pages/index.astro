---
import { getCollection, getEntryBySlug } from 'astro:content';
import BioBento from '../components/BioBento.astro';
import ProjectBento from '../components/ProjectBento.astro';
import LogoAbleton from '../Assets/software_logos/Ableton.webp';
import LogoReaper from '../Assets/software_logos/Reaper.webp';
import LogoLogicPro from '../Assets/software_logos/Logic_Pro.webp';
import LogoProTools from '../Assets/software_logos/Pro_Tools.webp';
import LogoFMOD from '../Assets/software_logos/Fmod.webp';
import LogoWwise from '../Assets/software_logos/Wwise.webp';
import LogoUnity from '../Assets/software_logos/Unity.webp';
import LogoCsharp from '../Assets/software_logos/Csharp.webp';
import LogoGit from '../Assets/software_logos/Git.webp';
import LogoDavinci from '../Assets/software_logos/Davinci_Resolve.webp';
import LogoCinema4D from '../Assets/software_logos/Cinema_4D.webp';
import LogoPhotoshop from '../Assets/software_logos/photoshop.webp';
import AtomCenterLogo from '../Assets/atom_center_logo.png';
import atomConfig from '../atom.config.js';
import { userTweaks } from '../user-tweaks.js';
import { calculateElectronPositions } from '../atom/utils/electronPositioning.js';
import { sanitizeMarkdown, sanitizeText } from '../utils/sanitize.js';

// Get all projects and compute domains from folder structure (prefix-ordered)
const projects = await getCollection('projects');

function parseDomainFolder(folder) {
  const m = folder.match(/^(\d+)[-_ ]?(.*)$/);
  const order = m ? parseInt(m[1], 10) : null;
  const nameRaw = (m ? m[2] : folder) || '';
  const name = nameRaw.trim();
  const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
  const display = name.replace(/[-_]+/g, ' ').trim().toUpperCase();
  return { order, name, slug, display };
}

// Build domain meta from top-level folder of each project
const domainMap = new Map(); // slug -> { order, name, slug, display }
const projectsWithDomains = projects.map(project => {
  const folder = (project.id.split('/')[0] || '').trim();
  const meta = parseDomainFolder(folder);
  if (meta.slug) {
    if (!domainMap.has(meta.slug)) domainMap.set(meta.slug, meta);
  }
  return {
    ...project,
    data: {
      ...project.data,
      domain: meta.slug || 'misc'
    }
  };
});

// Sort domains by numeric prefix, then alpha, and cap at 5
let domainMetaList = Array.from(domainMap.values());
domainMetaList.sort((a, b) => {
  const ao = a.order ?? Infinity;
  const bo = b.order ?? Infinity;
  if (ao !== bo) return ao - bo;
  return a.name.localeCompare(b.name);
});
const maxShells = 5;
if (domainMetaList.length > maxShells) {
  console.warn(`[atom] Domain folders exceed ${maxShells}; extra domains will be hidden:`, domainMetaList.slice(maxShells).map(d => d.slug));
}
domainMetaList = domainMetaList.slice(0, maxShells);
const domains = domainMetaList.map(d => d.slug);

// Calculate electron positions for each shell
const electronsByDomain = projectsWithDomains.reduce((acc, project) => {
  if (!acc[project.data.domain]) acc[project.data.domain] = [];
  acc[project.data.domain].push(project);
  return acc;
}, {});

// Asset resolution logic (borrowed from ProjectBento)
const ALL_ASSET_URLS = import.meta.glob('/src/content/projects/**/*.{jpg,jpeg,png,webp,gif,mp4,webm,mov}', {
  eager: true,
  query: '?url',
  import: 'default'
});

function resolveAssetUrl(path: string | undefined): string | undefined {
  if (!path) return undefined;
  const url = ALL_ASSET_URLS[path as keyof typeof ALL_ASSET_URLS];
  return typeof url === 'string' ? url : undefined;
}

function scanAssetsFolder(folder: string | undefined, explicitHeroBg?: string, explicitLogo?: string): {
  heroBg?: string,
  heroLogo?: string,
  heroIsVideo?: boolean,
  heroThumbnail?: string
} {
  if (!folder) return {};
  
  const norm = folder.replace(/\/+$/, '');
  const entries = Object.entries(ALL_ASSET_URLS)
    .filter(([p]) => p.startsWith(norm + '/'))
    .map(([p, url]) => ({ path: p, url }));

  const parts = entries.map(({ path, url }) => {
    const base = path.split('/').pop() || '';
    const name = base.replace(/\.[^.]+$/, '');
    const nameLC = name.toLowerCase();
    return { base, name, nameLC, url };
  });

  const heroFile = parts.find(p => p.nameLC === 'hero');
  const logoFile = parts.find(p => p.nameLC === 'logo');
  const thumbnailFile = parts.find(p => p.nameLC === 'thumbnail');
  const heroBg = resolveAssetUrl(explicitHeroBg) || heroFile?.url;
  const heroLogo = resolveAssetUrl(explicitLogo) || logoFile?.url;
  
  // Check if hero is a video file
  const heroIsVideo = heroFile?.base ? /\.(mp4|webm|mov)$/i.test(heroFile.base) : false;
  
  // Get thumbnail for video hero (only when hero is a video and thumbnail exists)
  const heroThumbnail = (heroIsVideo && thumbnailFile) ? thumbnailFile.url : undefined;

  return { heroBg, heroLogo, heroIsVideo, heroThumbnail };
}

// Enhanced project payload with preview data for electron hover
const projectSummaries = projectsWithDomains.map(p => {
  const bento = p.data.bento;
  let heroImage = '';
  let subtitle = '';
  
  if (p.data.useBentoLayout && bento) {
    // Bento projects: use asset resolution
    const assets = scanAssetsFolder(bento.assetsFolder, bento.hero?.backgroundImage, bento.hero?.logo);
    // For preview cards, use thumbnail if hero is video, otherwise use hero
    heroImage = assets.heroIsVideo && assets.heroThumbnail 
      ? assets.heroThumbnail 
      : (bento.hero?.backgroundImage || assets.heroBg || '');
    subtitle = bento.hero?.subtitle || '';
  } else {
    // Atomic projects: use image field
    heroImage = p.data.image || '';
  }
  
  // Fallback subtitle logic
  if (!subtitle) {
    subtitle = p.data.description.length > 60 
      ? p.data.description.slice(0, 60) + '...'
      : p.data.description;
  }
  
  return {
    slug: p.slug,
    title: p.data.title,
    altTitle: p.data.altTitle, // Optional shorter title for electron preview
    description: p.data.description,
    domain: p.data.domain,
    tech: p.data.tech,
    link: p.data.link,
    github: p.data.github,
    useBentoLayout: p.data.useBentoLayout,
    // NEW: Preview data for electron hover
    preview: {
      heroImage: heroImage || 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjVmNWY1Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJzeXN0ZW0tdWksIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5Qcm9qZWN0IEltYWdlPC90ZXh0Pjwvc3ZnPg==',
      subtitle: subtitle
    }
  };
});

// Prepare Bio payload from content collection (bio/about)
let bioPayload = {};
let bioEntry = null;
try {
  bioEntry = await getEntryBySlug('bio', 'about');
  if (bioEntry?.data) {
    const d = bioEntry.data as any;
    bioPayload = {
      title: sanitizeText(d.title) || '',
      subtitle: sanitizeText(d.subtitle) || '',
      bio: d.bio ? await sanitizeMarkdown(d.bio) : '',
      portrait: sanitizeText(d.portrait) || '/images/bio/arthur-portfolio.jpg',
      email: sanitizeText(d.email) || '',
      social: d.social || [],
      skills: d.skills || [],
    };
  }
} catch (error) {
  console.error('Failed to load bio data:', error);
}

// Bio payload successfully loaded

// Map of tool name -> logo URL for overlay rendering
const logosMap = {
  'Ableton': LogoAbleton,
  'Reaper': LogoReaper,
  'Logic Pro': LogoLogicPro,
  'Pro Tools': LogoProTools,
  'FMOD': LogoFMOD,
  'Wwise': LogoWwise,
  'Unity': LogoUnity,
  'C#': LogoCsharp,
  'Git': LogoGit,
  'DaVinci Resolve': LogoDavinci,
  'Cinema 4D': LogoCinema4D,
  'Photoshop': LogoPhotoshop,
};

// Helpers for label paths
function circlePathD(cx: number, cy: number, r: number) {
  // Draw full circle with two 180Â° arcs for Safari reliability
  const x0 = cx - r;
  const y0 = cy;
  const d = [
    `M ${x0} ${y0}`,
    `a ${r} ${r} 0 1 1 ${2 * r} 0`,
    `a ${r} ${r} 0 1 1 ${-2 * r} 0`
  ].join(' ');
  return d;
}

function arcPathD(cx: number, cy: number, r: number, startDeg: number, endDeg: number) {
  const toRad = (deg: number) => (deg * Math.PI) / 180;
  const sx = cx + r * Math.cos(toRad(startDeg));
  const sy = cy + r * Math.sin(toRad(startDeg));
  const ex = cx + r * Math.cos(toRad(endDeg));
  const ey = cy + r * Math.sin(toRad(endDeg));
  const sweep = endDeg > startDeg ? 1 : 0;
  const large = Math.abs(endDeg - startDeg) > 180 ? 1 : 0;
  return `M ${sx} ${sy} A ${r} ${r} 0 ${large} ${sweep} ${ex} ${ey}`;
}

// Prefer dynamic folder display names; fall back to overrides + slug transform
const DYNAMIC_NAMES: Record<string,string> = Object.fromEntries(domainMetaList.map(d => [d.slug, d.display]));
function displayNameForDomain(slug: string) {
  if (slug in DYNAMIC_NAMES) return DYNAMIC_NAMES[slug];
  const map = (atomConfig as any).domainDisplayNames || {};
  if (map && slug in map) return map[slug];
  return String(slug || '').replace(/-/g, ' ').toUpperCase();
}

// Compute dynamic shells and viewport
function computeShellsAndViewport() {
  const N = domains.length;
  const ds = (atomConfig as any).dynamicShells || {};
  const baseRadius = ds.baseRadius ?? 120;
  const baseGap = ds.baseGap ?? 80;
  const minGap = ds.minGap ?? 56;
  const maxGap = ds.maxGap ?? 110;
  const dirMode = ds.directionMode ?? 'alternate';
  const speedBase = ds.speed?.base ?? 9;
  const speedDelta = ds.speed?.deltaPerShell ?? 0;
  const factor = Math.max(1, 3 / Math.max(N, 1));
  const gapRaw = baseGap * factor;
  const gap = Math.min(maxGap, Math.max(minGap, gapRaw));
  const shells = Array.from({ length: N }, (_, i) => {
    const radius = baseRadius + i * gap;
    const direction = dirMode === 'cw' ? 1 : dirMode === 'ccw' ? -1 : (i % 2 === 0 ? 1 : -1);
    const speed = speedBase + i * speedDelta;
    return {
      radius,
      speed,
      direction,
      strokeWidth: (atomConfig as any).shells?.[0]?.strokeWidth ?? 4,
      hoverStrokeWidth: (atomConfig as any).shells?.[0]?.hoverStrokeWidth ?? 5,
      defaultOpacity: (atomConfig as any).shells?.[0]?.defaultOpacity ?? 0.3,
      hoverOpacity: (atomConfig as any).shells?.[0]?.hoverOpacity ?? 0.7,
      electronHoverOpacity: (atomConfig as any).shells?.[0]?.electronHoverOpacity ?? 0.2,
      color: '#000'
    };
  });
  const maxR = shells.length ? shells[shells.length - 1].radius : baseRadius;
  const atomScale = (userTweaks as any).atomScale ?? 1;
  const padding = ((userTweaks as any).viewportPadding ?? 80) * atomScale;
  const hoverR = (atomConfig as any).electrons?.hoverRadius ?? 22;
  const requiredSize = (maxR + hoverR + padding) * 2;
  const finalSize = Math.max((userTweaks as any).viewportSize ?? 900, requiredSize);
  const viewport = { width: finalSize, height: finalSize, centerX: finalSize / 2, centerY: finalSize / 2, padding };
  return { shells, viewport };
}

const { shells: dynamicShells, viewport: dynamicViewport } = computeShellsAndViewport();
const cfg = { ...(atomConfig as any), shells: dynamicShells, viewport: dynamicViewport, domains } as any;
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		
		<!-- PWA Manifest -->
		<link rel="manifest" href="/manifest.json" />
		<meta name="theme-color" content="#00b3b0" />
		<meta name="mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="default" />
		<meta name="apple-mobile-web-app-title" content="Atom Portfolio" />
		
		<!-- Build Metadata for Performance Monitoring -->
		<meta name="build-version" content={`${Date.now()}`} />
		<meta name="build-commit" content={import.meta.env.BUILD_COMMIT || 'local'} />
		<meta name="build-date" content={new Date().toISOString()} />
		
		<!-- Relaxed Content Security Policy for media embeds -->
		<meta http-equiv="Content-Security-Policy" content="
			default-src 'self';
			script-src 'self' 'unsafe-inline' 'unsafe-eval' https: data:;
			style-src 'self' 'unsafe-inline' https: data:;
			img-src 'self' data: https: blob:;
			media-src 'self' data: https: blob:;
			font-src 'self' data: https:;
			connect-src 'self' https:;
			worker-src 'self' blob:;
			child-src 'none';
			frame-src 'self' https: https://open.spotify.com https://w.soundcloud.com;
			object-src 'none';
			base-uri 'self';
			form-action 'self' https:;
			frame-ancestors 'none';
		">
		
		<title>Atom Portfolio</title>
			<style>
            body {
                margin: 0;
                padding: 0;
                background: #fff;
                font-family: system-ui, sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                overflow: hidden; /* prevent page scroll white borders during drag */
                user-select: none; /* avoid text selection while dragging */
            }

            /* Professional dark mode base (applies site-wide) */
            html[data-theme="dark"] body { 
                background: #0a0a0a; 
                color: #e4e4e7; 
            }
            
            .atom-container {
                display: flex;
                justify-content: center;
                align-items: center;
            }
            
            #atom-svg {
                cursor: grab;
                touch-action: none; /* prevent touch scrolling/zoom white borders */
                /* Use layout sizing for crisp vectors instead of CSS transform scaling */
                width: 100vmin;
                height: 100vmin;
            }

            /* Professional dark mode overrides for atom visuals */
            html[data-theme="dark"] #atom-svg .shell { 
                stroke: #ffffff !important; 
            }
            html[data-theme="dark"] #atom-svg .electron { 
                fill: #ffffff !important; 
                stroke: #ffffff !important; 
            }
            html[data-theme="dark"] #atom-svg .shell-label,
            html[data-theme="dark"] #atom-svg .orbit-label { 
                fill: #ffffff !important; 
            }
            html[data-theme="dark"] #atom-svg .nucleus { 
                fill: #ffffff !important; 
                stroke: #ffffff !important; 
            }
			
			.electron {
				cursor: pointer;
			}

            /* One-page overlay for project details (masked by clip-path) */
            #project-overlay {
                position: fixed;
                inset: 0;
                background: #fff;
                color: #000;
                z-index: 9999;
                display: none; /* shown via .open */
                overflow-y: auto; /* Allow vertical scrolling */
                overflow-x: hidden; /* Prevent horizontal overflow */
                /* Hard-edge fallback via clip-path */
                clip-path: circle(var(--r, 0px) at var(--x, 50%) var(--y, 50%));
                /* Soft edge via mask-image (progressive enhancement) */
                -webkit-mask-image: radial-gradient(
                  circle at var(--x, 50%) var(--y, 50%),
                  rgba(0,0,0,1) calc(var(--r, 0px) - var(--soft, 0px)),
                  rgba(0,0,0,0) var(--r, 0px)
                );
                mask-image: radial-gradient(
                  circle at var(--x, 50%) var(--y, 50%),
                  rgba(0,0,0,1) calc(var(--r, 0px) - var(--soft, 0px)),
                  rgba(0,0,0,0) var(--r, 0px)
                );
                will-change: clip-path, -webkit-mask-image, mask-image;
            }
            #project-overlay.open { display: block; }
            /* Professional dark theme for overlay */
            html[data-theme="dark"] #project-overlay { 
                background: #0f0f0f; 
                color: #e4e4e7; 
            }
            html[data-theme="dark"] #project-overlay .close-btn {
                background: #1a1a1a; 
                color: #f4f4f5; 
                border-color: #3a3a3a;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            }
            html[data-theme="dark"] #project-overlay .close-btn:hover {
                background: #2a2a2a;
                border-color: #5a5a5a;
                box-shadow: 0 6px 25px rgba(0, 0, 0, 0.6);
            }
            #project-overlay .inner {
                max-width: 900px;
                margin: 0 auto;
                padding: 48px 24px;
                opacity: 1; /* Opaque during opening for progressive reveal */
                transition: none;
            }
            
            /* Bento content should fill available space and be scrollable */
            #project-overlay #bento-content {
                width: 100%;
                height: auto;
                min-height: 100vh;
            }
            /* Ensure Bio uses its own layout widths/padding to match /bio */
            #project-overlay #bio-content.inner {
                max-width: none;
                padding: 0;
            }
            #project-overlay.open .inner { opacity: 1; }
            #project-overlay .close-btn {
                position: fixed;
                top: 16px;
                right: 16px;
                width: 36px; height: 36px;
                border: 1px solid #000; border-radius: 50%; background: #fff; color: #000;
                cursor: pointer; font-size: 18px; line-height: 34px; text-align: center;
                z-index: 10000; /* Ensure always on top */
                box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15); /* Subtle shadow for visibility */
                transition: all 0.2s ease;
            }
            #project-overlay .close-btn:hover {
                transform: scale(1.1);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            }

            /* Improve SVG text clarity, especially in Chrome */
            #atom-svg text {
                text-rendering: geometricPrecision;      /* Hint for precise glyph shapes */
                -webkit-font-smoothing: antialiased;     /* Chrome/WebKit */
                -moz-osx-font-smoothing: grayscale;      /* Firefox on macOS */
            }
            /* Ensure nucleus logo does not intercept pointer events */
            .nucleus-logo { pointer-events: none; }
            html[data-theme="dark"] .nucleus-logo { 
                filter: invert(1) brightness(0.9); 
            }
            
            /* Pruned old bio styles (legacy) */

				/* BioBento component owns its own styles; no duplicates here */

            /* Shell labels (curved text on rings) */
            .shell-label { fill: #000; letter-spacing: 2px; text-transform: uppercase; }
            .shell-label-rotor { pointer-events: none; }
            /* Ring mode: prefer arc on small screens */
            .shell-label--arc { display: none; }
            @media (max-width: 700px) {
              .shell-label--full { display: none; }
              .shell-label--arc { display: inline; opacity: 0.35 !important; }
            }
            /* Orbiting word mode */
            .orbit-label { fill: #000; letter-spacing: 2px; text-transform: uppercase; }
            
            /* Electron Preview Component */
            .electron-preview {
                position: fixed;
                z-index: 10000; /* Above everything */
                background: #fff;
                border-radius: var(--preview-border-radius, 8px);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                width: var(--preview-width, 320px);
                height: var(--preview-height, 120px);
                display: flex;
                overflow: hidden;
                pointer-events: none; /* Don't interfere with mouse events */
                border: 1px solid rgba(0, 0, 0, 0.1);
                transform-origin: top left;
                container-type: size; /* Enable container queries */
            }

            /* Professional dark mode for electron preview */
            html[data-theme="dark"] .electron-preview {
                background: #1a1a1a;
                border: 1px solid #3a3a3a;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
                color: #e4e4e7;
            }

            html[data-theme="dark"] .preview-hero {
                background: #262626;
            }

            html[data-theme="dark"] .preview-title {
                color: #f4f4f5;
            }

            html[data-theme="dark"] .preview-subtitle {
                color: #a1a1aa;
            }
            
            .preview-content {
                padding: min(var(--preview-content-padding, 16px), calc(var(--preview-height, 120px) * 0.15));
                flex: 1;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                min-width: 0; /* Allow text truncation */
                /* Max-width set dynamically via JavaScript */
                max-width: var(--preview-content-max-width, 150px);
                overflow: hidden; /* Prevent content from overflowing */
            }
            
            .preview-hero {
                /* Dynamic sizing: use smaller of (configured size) or (height - 2*margin) */
                width: min(var(--preview-hero-size, 88px), calc(var(--preview-height, 120px) - 2 * var(--preview-hero-margin, 16px)));
                height: min(var(--preview-hero-size, 88px), calc(var(--preview-height, 120px) - 2 * var(--preview-hero-margin, 16px)));
                position: relative;
                overflow: hidden;
                background: #f5f5f5;
                flex-shrink: 0;
                margin: var(--preview-hero-margin, 16px);
                border-radius: var(--preview-hero-radius, 8px);
                align-self: center; /* Center vertically when height is constrained */
            }
            
            .preview-img {
                width: 100%;
                height: 100%;
                object-fit: cover;
                object-position: center;
            }
            
            .preview-title {
                font-size: min(var(--preview-title-size, 16px), calc(var(--preview-height, 120px) * 0.15));
                font-weight: 700;
                margin: 0 0 min(8px, calc(var(--preview-height, 120px) * 0.07)) 0;
                line-height: 1.1;
                color: #000;
                overflow: hidden;
                word-wrap: break-word;
                hyphens: auto;
                /* Limit to 2 lines max for long titles */
                display: -webkit-box;
                -webkit-line-clamp: 2;
                -webkit-box-orient: vertical;
                /* Fallback for browsers without line-clamp */
                max-height: calc(2 * 1.2em);
            }
            
            .preview-subtitle {
                font-size: min(var(--preview-subtitle-size, 13px), calc(var(--preview-height, 120px) * 0.12));
                color: #666;
                margin: 0;
                line-height: 1.2;
                overflow: hidden;
                word-wrap: break-word;
                hyphens: auto;
                /* Limit to 3 lines max for subtitle */
                display: -webkit-box;
                -webkit-line-clamp: 3;
                -webkit-box-orient: vertical;
                /* Fallback for browsers without line-clamp */
                max-height: calc(3 * 1.2em);
                flex: 1; /* Take remaining space after title */
            }
            
            /* Responsive classes for different preview heights */
            .electron-preview.preview-compact .preview-title {
                font-size: 12px !important;
                margin-bottom: 2px !important;
                -webkit-line-clamp: 1;
                max-height: calc(1 * 1.1em);
            }
            
            .electron-preview.preview-compact .preview-subtitle {
                display: none;
            }
            
            .electron-preview.preview-compact .preview-hero {
                width: calc(var(--preview-height, 120px) - 20px) !important;
                height: calc(var(--preview-height, 120px) - 20px) !important;
                margin: 10px !important;
            }
            
            .electron-preview.preview-small .preview-title {
                font-size: 14px !important;
                -webkit-line-clamp: 1;
                max-height: calc(1 * 1.1em);
            }
            
            .electron-preview.preview-small .preview-subtitle {
                font-size: 11px !important;
                -webkit-line-clamp: 2;
                max-height: calc(2 * 1.2em);
            }

            /* Focus styles for keyboard navigation accessibility */
            .electron:focus {
                outline: 2px solid var(--accent-color, #00b3b0);
                outline-offset: 2px;
                border-radius: 50%;
            }

            .nucleus:focus {
                outline: 3px solid var(--accent-color, #00b3b0);
                outline-offset: 4px;
                border-radius: 50%;
            }

            /* Enhanced focus visibility in dark mode */
            html[data-theme="dark"] .electron:focus {
                outline-color: #4ade80;
                box-shadow: 0 0 8px rgba(74, 222, 128, 0.3);
            }

            html[data-theme="dark"] .nucleus:focus {
                outline-color: #4ade80;
                box-shadow: 0 0 12px rgba(74, 222, 128, 0.4);
            }

            /* Focus-visible for modern browsers (removes outline on mouse clicks) */
            .electron:focus:not(:focus-visible) {
                outline: none !important;
                box-shadow: none !important;
            }

            .nucleus:focus:not(:focus-visible) {
                outline: none !important;
                box-shadow: none !important;
            }

            /* Enhanced focus-visible support with JS fallback */
            .electron:focus:not(.focus-visible) {
                outline: none !important;
                box-shadow: none !important;
            }

            .nucleus:focus:not(.focus-visible) {
                outline: none !important;
                box-shadow: none !important;
            }
		</style>

        <!-- Theme init (before paint) -->
        <script>
          (function(){
            try {
              const saved = localStorage.getItem('theme');
              const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
              const theme = saved || (prefersDark ? 'dark' : 'light');
              document.documentElement.setAttribute('data-theme', theme);
            } catch {}
          })();
        </script>
	</head>
	<body>
		<!-- Theme toggle button -->
		<button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode" title="Toggle theme"
			style="position:fixed;top:16px;left:16px;z-index:10001;border:1px solid currentColor;border-radius:999px;padding:8px 12px;cursor:pointer;backdrop-filter:saturate(140%) blur(6px);">
			<span id="theme-toggle-label">Dark</span>
		</button>
		<div class="atom-container">
				<svg 
					id="atom-svg"
					width={cfg.viewport.width} 
					height={cfg.viewport.height} 
					viewBox={`0 0 ${cfg.viewport.width} ${cfg.viewport.height}`}
					xmlns="http://www.w3.org/2000/svg"
				>
				<!-- Nucleus (clickable like an electron, not draggable) -->
				<circle 
					id="nucleus-circle"
					class="electron nucleus"
					cx={cfg.viewport.centerX}
					cy={cfg.viewport.centerY}
					r={atomConfig.nucleus.radius}
					fill={atomConfig.electrons.color}
					stroke={atomConfig.nucleus.color}
					stroke-width={atomConfig.nucleus.strokeWidth}
					role="button"
					aria-label="View bio and portfolio information"
					tabindex="0"
				/>
				<image 
					class="nucleus-logo"
					x={cfg.viewport.centerX - atomConfig.nucleus.radius * (atomConfig.nucleus.logo.size / 2) + atomConfig.nucleus.logo.offsetX}
					y={cfg.viewport.centerY - atomConfig.nucleus.radius * (atomConfig.nucleus.logo.size / 2) + atomConfig.nucleus.logo.offsetY}
					width={atomConfig.nucleus.radius * atomConfig.nucleus.logo.size}
					height={atomConfig.nucleus.radius * atomConfig.nucleus.logo.size}
					href={AtomCenterLogo.src}
				/>

				<!-- Orbital Shells -->
				{domains.map((domain, shellIndex) => {
					const shell = cfg.shells[shellIndex] || cfg.shells[cfg.shells.length - 1];
					const electronsInShell = electronsByDomain[domain] || [];
					
					// Random positioning with collision avoidance
					const minDistance = atomConfig.spacing?.minElectronDistance || 60;
					const count = electronsInShell.length;
					
					let electronPositions = [];
					
					if (count === 1) {
						electronPositions = [Math.random() * 360];
					} else if (count > 1) {
						// Generate random positions with minimum distance enforcement
						for (let i = 0; i < count; i++) {
							let attempts = 0;
							let validPosition = false;
							let newAngle;
							
							while (!validPosition && attempts < 100) {
								newAngle = Math.random() * 360;
								validPosition = true;
								
								// Check distance to all existing positions
								for (let existingAngle of electronPositions) {
									const angleDiff = Math.abs(newAngle - existingAngle);
									const minDist = Math.min(angleDiff, 360 - angleDiff); // Handle wrap-around
									
									if (minDist < minDistance) {
										validPosition = false;
										break;
									}
								}
								attempts++;
							}
							
							// If we couldn't find a valid position after many attempts, just place it randomly
							electronPositions.push(newAngle || Math.random() * 360);
						}
					}
					
					
					return (
						<g data-shell={shellIndex} data-domain={domain}>
							{/* Label defs and rendering by mode */}
							{atomConfig.labels?.enabled && (atomConfig.labels?.mode === 'ring' || atomConfig.labels?.mode === 'ringPattern') ? (
								<defs>
                    {(() => {
                      const r = shell.radius + (atomConfig.labels?.offsetPx ?? 16);
                      const cx = cfg.viewport.centerX;
                      const cy = cfg.viewport.centerY;
										const fullId = `label-path-full-${shellIndex}`;
										const arcId = `label-path-arc-${shellIndex}`;
										const arcDeg = atomConfig.labels?.mobileArcDegrees ?? 150;
										const start = -90 - arcDeg / 2;
										const end = -90 + arcDeg / 2;
										return (
											<>
												<path id={fullId} d={circlePathD(cx, cy, r)} fill="none" />
												<path id={arcId} d={arcPathD(cx, cy, r, start, end)} fill="none" />
											</>
										);
									})()}
								</defs>
							) : null}
							{atomConfig.labels?.enabled && (atomConfig.labels?.mode === 'ring' || atomConfig.labels?.mode === 'ringPattern') ? (
								<g class="shell-label-rotor" data-shell-index={shellIndex} style="pointer-events: none;">
									{(() => {
										const display = displayNameForDomain(domain);
                  const repeatsByShell = atomConfig.labels?.pattern?.repeatsByShell || [];
                  const density = atomConfig.labels?.pattern?.densityPxPerRepeat ?? 26;
                  const minRep = atomConfig.labels?.pattern?.minRepeats ?? 3;
                  const maxRep = atomConfig.labels?.pattern?.maxRepeats ?? 40;
                  const rLabel = shell.radius + (atomConfig.labels?.offsetPx ?? 16);
                  const circ = 2 * Math.PI * rLabel;
                  const autoRep = Math.max(minRep, Math.min(maxRep, Math.round(circ / Math.max(8, density))));
                  const repeats = Math.max(1, (repeatsByShell[shellIndex] ?? autoRep));
                  const sep = atomConfig.labels?.pattern?.separator ?? ' â¢ ';
                  const labelText = Array.from({ length: repeats }, () => display).join(sep);
										const fullHref = `#label-path-full-${shellIndex}`;
										const arcHref = `#label-path-arc-${shellIndex}`;
										const isPattern = atomConfig.labels?.mode === 'ringPattern';
										const offsets = atomConfig.labels?.pattern?.offsetsPercentByShell || [];
										const startOffset = isPattern ? String(offsets[shellIndex % offsets.length] || 0) + '%' : '0%';
										return (
											<>
												<text class="shell-label shell-label--full" data-shell-index={shellIndex} style={`opacity:${atomConfig.labels?.idleOpacity ?? 0.35}`}
													font-size={atomConfig.labels?.fontSize}
													text-anchor="start"
												>
													<textPath href={fullHref} startOffset={startOffset}>{labelText}</textPath>
												</text>
												<text class="shell-label shell-label--arc" data-shell-index={shellIndex} style="opacity:0"
													font-size={atomConfig.labels?.fontSize}
													text-anchor="middle"
												>
													<textPath href={arcHref} startOffset="50%">{display}</textPath>
												</text>
											</>
										);
									})()}
								</g>
							) : null}

                {atomConfig.labels?.enabled && (atomConfig.labels?.mode === 'orbiting') ? (
                  <g class="shell-label-rotor" data-shell-index={shellIndex} style="pointer-events: none;">
                    {(() => {
                      const cx = cfg.viewport.centerX;
                      const cy = cfg.viewport.centerY;
                      const r = Math.max(10, shell.radius - (atomConfig.labels?.wordOrbit?.innerOffsetPx ?? 20));
                      const arcDeg = atomConfig.labels?.wordOrbit?.arcDegrees ?? 160;
                      const center = atomConfig.labels?.wordOrbit?.centerAngleDeg ?? -90;
                      const start = center - arcDeg / 2;
                      const end = center + arcDeg / 2;
                      const id = `orbit-label-path-${shellIndex}`;
                      const display = displayNameForDomain(domain);
                      return (
                        <>
                          <defs>
                            <path id={id} d={arcPathD(cx, cy, r, start, end)} fill="none" />
                          </defs>
                          <text class="orbit-label" style={`opacity:${atomConfig.labels?.idleOpacity ?? 0.35}`} font-size={atomConfig.labels?.fontSize}>
                            <textPath href={`#${id}`} startOffset="50%" text-anchor="middle">{display}</textPath>
                          </text>
                        </>
                      );
                    })()}
                  </g>
                ) : null}

							<!-- Shell orbit path -->
              <circle 
                class="shell"
                cx={cfg.viewport.centerX}
                cy={cfg.viewport.centerY}
                r={shell.radius}
								fill="none"
								stroke={shell.color}
								stroke-width={shell.strokeWidth}
								style={`opacity: ${userTweaks.shell.default.opacity}`}
								data-shell-index={shellIndex}
							/>
							
							<!-- Electrons on this shell -->
							{electronsInShell.map((project, electronIndex) => {
								const angleDegrees = electronPositions[electronIndex];
								const angleRadians = (angleDegrees * Math.PI) / 180; // Convert to radians for trig functions
                  const x = cfg.viewport.centerX + shell.radius * Math.cos(angleRadians);
                  const y = cfg.viewport.centerY + shell.radius * Math.sin(angleRadians);
								
								return (
									<circle 
										class="electron"
										cx={x}
										cy={y}
										r={atomConfig.electrons.radius}
										fill={atomConfig.electrons.color}
										stroke={atomConfig.electrons.color}
										stroke-width={atomConfig.electrons.strokeWidth}
										data-project={project.slug}
										data-shell={shellIndex}
										data-shell-index={shellIndex}
										data-electron-index={electronIndex}
										data-angle={angleDegrees}
										role="button"
										aria-label={`View project: ${project.data.title} - ${project.data.description.slice(0, 60)}...`}
										tabindex="0"
									>
										<title>{project.data.title}</title>
									</circle>
								);
							})}
						</g>
					);
				})}
			</svg>
			
			<!-- Electron Hover Preview -->
			<div id="electron-preview" class="electron-preview" style="display: none;">
				<div class="preview-content">
					<h3 id="preview-title" class="preview-title"></h3>
					<p id="preview-subtitle" class="preview-subtitle"></p>
				</div>
				<div class="preview-hero">
					<img id="preview-image" src="" alt="" class="preview-img">
				</div>
			</div>
		</div>

        <!-- Client data payload for overlay -->
        <script type="application/json" id="project-data" set:html={JSON.stringify(projectSummaries)}></script>
        <script type="application/json" id="bio-data" set:html={JSON.stringify(bioPayload)}></script>
        <script type="application/json" id="logos-map" set:html={JSON.stringify(logosMap)}></script>
        <script type="application/json" id="cfg-data" set:html={JSON.stringify(cfg)}></script>

        <!-- Theme toggle wiring -->
        <script>
          (function(){
            const btn = document.getElementById('theme-toggle');
            const label = document.getElementById('theme-toggle-label');
            function applyLabel() {
              const t = document.documentElement.getAttribute('data-theme') || 'light';
              label.textContent = t === 'dark' ? 'Light' : 'Dark';
              // Ensure button color contrasts background
              const fg = t === 'dark' ? '#fff' : '#000';
              const bg = t === 'dark' ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)';
              btn.style.color = fg;
              btn.style.borderColor = fg;
              btn.style.background = bg;
            }
            applyLabel();
            btn.addEventListener('click', () => {
              const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
              document.documentElement.setAttribute('data-theme', cur);
              try { localStorage.setItem('theme', cur); } catch {}
              applyLabel();
            });
          })();
        </script>

        <!-- Overlay (handles both projects and bio) -->
        <div id="project-overlay" aria-hidden="true">
          <button id="overlay-close" class="close-btn" aria-label="Close">Ã</button>
          
          <!-- Project content template -->
          <div id="project-content" class="inner" role="dialog" aria-modal="true" aria-labelledby="overlay-title">
            <h1 id="overlay-title"></h1>
            <p id="overlay-desc"></p>
            <div id="overlay-tech" style="display:flex;gap:8px;flex-wrap:wrap;margin:12px 0 16px;"></div>
            <div id="overlay-actions" style="display:flex;gap:12px;margin:8px 0 0;"></div>
          </div>
          
          <!-- Bento layout for special projects -->
          <div id="bento-content" style="display:none;">
            {projectsWithDomains.filter(p => p.data.useBentoLayout).map(project => (
              <div class="bento-project" data-project-slug={project.slug} style="display:none;">
                <ProjectBento project={project} />
              </div>
            ))}
          </div>
          
          <!-- Bio content template (Bento style, shared component) -->
          <div id="bio-content" role="dialog" aria-modal="true" aria-label="Bio" style="display:none;">
            <BioBento data={bioEntry?.data || {}} />
          </div>
        </div>

		<script>
			// PLACEHOLDER: Tone.js is temporary - will be replaced with custom OGG audio files
			// See docs/history/PHASE_LOGS.md Phase 3C for audio architecture plan
			import { Synth, start, now, gainToDb, context } from 'tone';
			import { gsap, Draggable } from 'gsap/all';
			import { OrbitSystem } from '../atom/core/OrbitSystem.js';
			import atomConfig from '../atom.config.js';
			
			// Initialize orbit system when DOM is ready
			document.addEventListener('DOMContentLoaded', () => {
				// console.log('Initializing Atom Portfolio...');
				// console.log('GSAP version:', gsap.version);
				
				// Minimum distance system is working correctly!
				
				// Read dynamic config generated server-side (fallback to atomConfig)
				const cfgDataNode = document.getElementById('cfg-data');
				let cfg = null;
				try { cfg = cfgDataNode ? JSON.parse(cfgDataNode.textContent) : null; } catch {}
				if (!cfg) cfg = atomConfig;

				// Set CSS custom properties for electron preview on page load
				if (cfg.electronPreview) {
					const root = document.documentElement;
					root.style.setProperty('--preview-width', cfg.electronPreview.width + 'px');
					root.style.setProperty('--preview-height', cfg.electronPreview.height + 'px');
					root.style.setProperty('--preview-border-radius', cfg.electronPreview.borderRadius + 'px');
					root.style.setProperty('--preview-content-padding', cfg.electronPreview.contentPadding + 'px');
					root.style.setProperty('--preview-hero-size', cfg.electronPreview.heroSize + 'px');
					root.style.setProperty('--preview-hero-radius', cfg.electronPreview.heroRadius + 'px');
					root.style.setProperty('--preview-hero-margin', cfg.electronPreview.heroMargin + 'px');
					root.style.setProperty('--preview-title-size', cfg.electronPreview.titleSize + 'px');
					root.style.setProperty('--preview-subtitle-size', cfg.electronPreview.subtitleSize + 'px');
					
					// Calculate available width for text content
					const actualHeroSize = Math.min(cfg.electronPreview.heroSize, cfg.electronPreview.height - 2 * cfg.electronPreview.heroMargin);
					const textMaxWidth = cfg.electronPreview.width - actualHeroSize - 2 * cfg.electronPreview.heroMargin - 2 * cfg.electronPreview.contentPadding;
					root.style.setProperty('--preview-content-max-width', Math.max(textMaxWidth, 100) + 'px'); // Minimum 100px
				}

				// Create and start orbit system
				const orbitSystem = new OrbitSystem(cfg);
				orbitSystem.init();
				orbitSystem.start();
				
				// Store reference globally immediately for event handlers
				window.orbitSystem = orbitSystem;

				// PLACEHOLDER: Atom Sound System - replace with OGG file system
				class AtomSoundSystem {
					constructor(config) {
						this.config = config?.atomSounds || { enabled: false };
						this.synth = null;
						this.isInitialized = false;
						this.lastSoundState = null; // Track last sound played to prevent repetition
					}

					async init() {
						if (!this.config.enabled || this.isInitialized) return;
						
						try {
							// PLACEHOLDER: Replace with Web Audio API and OGG file loading
							this.synth = new Synth({
								oscillator: { type: 'sine' },
								envelope: {
									attack: this.config.synthesis?.attack || 0.02,
									decay: this.config.synthesis?.decay || 0.4,
									sustain: this.config.synthesis?.sustain || 0,
									release: this.config.synthesis?.release || 1.2
								}
							}).toDestination();

							this.synth.volume.value = gainToDb(this.config.volume || 0.2);
							this.isInitialized = true;
							// console.log('ð Atom Sound System initialized (Tone.js placeholder)');
						} catch (error) {
							// console.warn('Failed to initialize atom sounds:', error);
						}
					}

					async playSound(eventType, stateKey = null) {
						if (!this.config.enabled || !this.isInitialized) return;
						
						// Prevent repetition for state-based sounds (like hover)
						if (stateKey && this.lastSoundState === stateKey) {
							return; // Already played this state, skip
						}
						
						const pitch = this.config.events?.[eventType];
						if (!pitch) return;

						try {
							// Ensure audio context is started
							if (context.state !== 'running') {
								await start();
							}

							// PLACEHOLDER: Replace with Web Audio API buffer source playback
							// Play the sound with slight timing offset to prevent conflicts
							const when = now() + 0.005;
							this.synth.triggerAttackRelease(pitch, '8n', when);
							
							// Track this state to prevent repetition
							if (stateKey) {
								this.lastSoundState = stateKey;
							}
							
							// console.log(`ð Playing ${eventType}: ${pitch} (state: ${stateKey || 'none'})`);
						} catch (error) {
							// console.warn(`Atom sound error for ${eventType}:`, error);
						}
					}

					// Simplified drag sounds: detach + drop only
					startDragSequence(electronId) {
						// PLACEHOLDER: Play detach sound when starting to drag - replace with OGG file playback
						this.playSound('electronDragStart', `drag-start-${electronId}`);
						// console.log(`ðµ Electron detached (${electronId})`);
					}

					stopDragSequence(snapBack = false) {
						// PLACEHOLDER: Play drop sound when releasing - replace with OGG file playback
						if (snapBack) {
							this.playSound('electronDragSnap'); // Satisfying snap back
						} else {
							this.playSound('electronDragRelease'); // Gentle release
						}
						
						// console.log(`ðµ Electron dropped (snapBack: ${snapBack})`);
					}
				}

				// Initialize atom sound system
				const atomSounds = new AtomSoundSystem(cfg);
				atomSounds.init(); // Initialize on page load for zero latency

            // Labels rotation setup
				const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
				let labelTweens = [];
				const labelTweenByShell = new Map();
				(function initLabelRotation(){
            				  try {
            				    if (!atomConfig.labels?.enabled) return;
            				    // Respect reduced motion only if labels.rotate.respectReducedMotion is true
            				    if (prefersReduced && (atomConfig.labels?.rotate?.respectReducedMotion === true)) return;
				    if (!atomConfig.labels?.rotate?.enabled) return;
                const mode = atomConfig.labels?.mode || 'ring';
                const rotors = document.querySelectorAll('.shell-label-rotor');
                let created = 0;
                rotors.forEach((rotor) => {
                  const shellIndex = parseInt(rotor.getAttribute('data-shell-index') || '0');
                  const dir = cfg.shells[shellIndex]?.direction ?? 1;
                  const speed = atomConfig.labels.rotate.speedsByShell?.[shellIndex] ?? 100; // seconds per revolution
                  let tween = null;
                  if (mode === 'ring') {
                    tween = gsap.to(rotor, {
                      rotation: `+=${360 * dir}`,
                      duration: speed,
                      ease: 'none',
                      repeat: -1,
                      svgOrigin: `${cfg.viewport.centerX} ${cfg.viewport.centerY}`
                    });
                  } else if (mode === 'orbiting') {
                    // orbiting mode: animate startOffset of the textPath along full circle
                    const tp = rotor.querySelector('textPath');
                    if (!tp) return;
                    const start = 0;
                    const end = dir >= 0 ? 100 : -100;
                    const state = { p: start };
                    tween = gsap.to(state, {
                      p: end,
                      duration: speed,
                      ease: 'none',
                      repeat: -1,
                      onUpdate: () => {
                        const v = ((state.p % 100) + 100) % 100;
                        tp.setAttribute('startOffset', v + '%');
                      }
                    });
                  } else if (mode === 'ringPattern') {
                    // Static pattern: no tween
                    tween = null;
                  }
                  if (tween) {
                    labelTweens.push(tween);
                    labelTweenByShell.set(shellIndex, tween);
                    created++;
                  }
                });
            				    console.log(`[labels] mode=${mode} rotors=${rotors.length} tweens=${created} reduced=${prefersReduced}`);
				  } catch(e) { console.warn('Label rotation init failed', e); }
				})();

				function pauseLabelRotation() { try { labelTweens.forEach(t => t?.pause()); } catch {} }
				function resumeLabelRotation() {
				  try {
				    if (prefersReduced && atomConfig.motion?.respectReducedMotion) return;
				    labelTweens.forEach(t => t?.resume());
				  } catch {}
				}

				// Base viewBox size used for hitbox math (no CSS transform scaling)
				const baseW = cfg.viewport.width;
				const baseH = cfg.viewport.height;
				
			// Register GSAP Draggable
			gsap.registerPlugin(Draggable);

            // Overlay state and helpers
            const overlay = document.getElementById('project-overlay');
            const closeBtn = document.getElementById('overlay-close');
            
            // Project overlay elements
            const projectContent = document.getElementById('project-content');
            const titleEl = document.getElementById('overlay-title');
            const descEl = document.getElementById('overlay-desc');
            const techEl = document.getElementById('overlay-tech');
            const actionsEl = document.getElementById('overlay-actions');
            
            // Bio overlay elements (Bento style)
            const bioContent = document.getElementById('bio-content');
            
            // Data
            const projectDataEl = document.getElementById('project-data');
            const bioDataEl = document.getElementById('bio-data');
            const logosMapEl = document.getElementById('logos-map');
            const PROJECTS = projectDataEl ? JSON.parse(projectDataEl.textContent) : [];
            const BIO_DATA = bioDataEl ? JSON.parse(bioDataEl.textContent) : {};
            const LOGOS = logosMapEl ? JSON.parse(logosMapEl.textContent) : {};
            const projectBySlug = new Map(PROJECTS.map(p => [p.slug, p]));
            
            let overlayOpen = false;
            let overlayR = 0;
            let lastFocused = null;
            let currentElectron = null;
            let currentOverlayType = null; // 'project' or 'bio'

            function getCoverRadius(x, y) {
              const vw = window.innerWidth, vh = window.innerHeight;
              const dx = Math.max(x, vw - x);
              const dy = Math.max(y, vh - y);
              return Math.hypot(dx, dy);
            }

            function fillProjectOverlay(p) {
              titleEl.textContent = p.title || '';
              descEl.textContent = p.description || '';
              techEl.innerHTML = '';
              if (Array.isArray(p.tech)) {
                p.tech.forEach(t => {
                  const span = document.createElement('span');
                  span.textContent = t;
                  span.style.border = '1px solid #000';
                  span.style.padding = '2px 8px';
                  span.style.borderRadius = '999px';
                  span.style.fontSize = '12px';
                  techEl.appendChild(span);
                });
              }
              actionsEl.innerHTML = '';
              if (p.link) {
                const a = document.createElement('a'); a.href = p.link; a.target = '_blank'; a.rel='noreferrer noopener'; a.textContent = 'Live'; a.style.borderBottom='1px solid #000'; a.style.textDecoration='none'; actionsEl.appendChild(a);
              }
              if (p.github) {
                const a = document.createElement('a'); a.href = p.github; a.target = '_blank'; a.rel='noreferrer noopener'; a.textContent = 'GitHub'; a.style.borderBottom='1px solid #000'; a.style.textDecoration='none'; actionsEl.appendChild(a);
              }
            }

            // fillBioOverlay removed - BioBento component is self-contained and server-hydrated

            function openProjectOverlay(slug, cx, cy, electronEl) {
              const p = projectBySlug.get(slug);
              if (!p || overlayOpen) return;
              
              currentOverlayType = 'project';
              overlayOpen = true;
              lastFocused = document.activeElement;
              currentElectron = electronEl;
              if (currentElectron && window.orbitSystem) window.orbitSystem.pauseElectron(currentElectron);
              pauseLabelRotation();

              // Check if project uses bento layout
              const bentoContent = document.getElementById('bento-content');
              if (p.useBentoLayout) {
                // Show bento content, hide others
                projectContent.style.display = 'none';
                bioContent.style.display = 'none';
                bentoContent.style.display = 'block';
                
                // Hide all bento projects first
                const allBentoProjects = bentoContent.querySelectorAll('.bento-project');
                allBentoProjects.forEach(bp => bp.style.display = 'none');
                
                // Show the specific bento project
                const targetBentoProject = bentoContent.querySelector(`[data-project-slug="${slug}"]`);
                if (targetBentoProject) {
                  targetBentoProject.style.display = 'block';
                  
                  // Reset animation state for bento cards
                  if (typeof window.resetBentoCards === 'function') {
                    window.resetBentoCards();
                  }
                }
              } else {
                // Show project content, hide others
                projectContent.style.display = 'block';
                bioContent.style.display = 'none';
                bentoContent.style.display = 'none';
                fillProjectOverlay(p);
              }
              overlay.style.setProperty('--x', `${cx}px`);
              overlay.style.setProperty('--y', `${cy}px`);
              overlay.style.setProperty('--r', `0px`);
              // Apply soft edge for project open
              try {
                const soft = (atomConfig.navTransition?.edgeSoftnessPx ?? 0);
                overlay.style.setProperty('--soft', `${soft}px`);
              } catch {}
              overlay.style.display = 'block';
              overlay.setAttribute('aria-hidden', 'false');
              const R = getCoverRadius(cx, cy);
              const useNav = !!(atomConfig.navTransition?.enabled);
              const dur = ((useNav ? atomConfig.navTransition?.inMs : atomConfig.overlayTransition?.openMs) ?? 600) / 1000;
              const easeOpen = (useNav ? atomConfig.navTransition?.easing : atomConfig.overlayTransition?.easing) ?? 'power2.inOut';
              const state = { r: 0 };
              gsap.to(state, {
                r: R,
                duration: dur,
                ease: easeOpen,
                onUpdate: function () {
                  overlayR = state.r;
                  overlay.style.setProperty('--r', `${overlayR}px`);
                  
                  
                  
                  // Block input during early phase
                  if (atomConfig.navTransition?.blockInput) {
                    const p = this.progress();
                    overlay.style.pointerEvents = p < 0.85 ? 'none' : 'auto';
                  }
                },
                onComplete: () => {
                  overlay.classList.add('open');
                  overlay.style.pointerEvents = 'auto';
                  
                  // Only push history for non-bento projects (bento stays in overlay)
                  const currentProject = projectBySlug.get(slug);
                  if (!currentProject?.useBentoLayout) {
                    try { history.pushState({ overlay: true, slug }, '', `/projects/${slug}`); } catch {}
                  }
                  
                  // Trigger bento card animations for bento projects
                  if (p.useBentoLayout && typeof window.animateBentoCards === 'function') {
                    // Small delay to ensure the overlay is fully visible
                    setTimeout(() => {
                      window.animateBentoCards();
                    }, 100);
                  }
                  
                  closeBtn.focus({ preventScroll: true });
                }
              });
            }

            async function openBioOverlay(cx, cy) {
              if (overlayOpen) return;
              
              currentOverlayType = 'bio';
              overlayOpen = true;
              lastFocused = document.activeElement;
              pauseLabelRotation();

              // Show bio content, hide project content
              projectContent.style.display = 'none';
              bioContent.style.display = 'block';
              
              // BioBento is already hydrated with fresh data from server-side bioPayload
              // No need to dynamically update since the component is self-contained
              
              // Restart bento animations for overlay context
              if (typeof window.restartBioBentoAnimations === 'function') {
                window.restartBioBentoAnimations();
              }
              
              overlay.style.setProperty('--x', `${cx}px`);
              overlay.style.setProperty('--y', `${cy}px`);
              overlay.style.setProperty('--r', `0px`);
              // Apply soft edge for bio overlay (configurable)
              try {
                const soft = (atomConfig.overlayTransition?.edgeSoftnessPx ?? 0);
                overlay.style.setProperty('--soft', `${soft}px`);
              } catch {}
              overlay.style.display = 'block';
              overlay.setAttribute('aria-hidden', 'false');
              const R = getCoverRadius(cx, cy);
              const dur = (atomConfig.overlayTransition?.openMs ?? 600) / 1000;
              const state = { r: 0 };
              gsap.to(state, {
                r: R,
                duration: dur,
                ease: atomConfig.overlayTransition?.easing ?? 'power2.inOut',
                onUpdate: () => {
                  overlayR = state.r;
                  overlay.style.setProperty('--r', `${overlayR}px`);
                },
                onComplete: () => {
                  overlay.classList.add('open');
                  // Keep one-page feel; no route push for bio
                  closeBtn.focus({ preventScroll: true });
                }
              });
            }


            function closeOverlay() {
              if (!overlayOpen) return;
              overlayOpen = false;
              const useNav = currentOverlayType === 'project' && !!(atomConfig.navTransition?.enabled);
              const dur = ((useNav ? atomConfig.navTransition?.outMs : atomConfig.overlayTransition?.closeMs) ?? 520) / 1000;
              const easeClose = (useNav ? atomConfig.navTransition?.easing : atomConfig.overlayTransition?.easing) ?? 'power2.inOut';
              const state = { r: overlayR };
              overlay.classList.remove('open');
              gsap.to(state, {
                r: 0,
                duration: dur,
                ease: easeClose,
                onUpdate: () => {
                  overlayR = state.r;
                  overlay.style.setProperty('--r', `${overlayR}px`);
                },
                onComplete: () => {
                  overlay.style.display = 'none';
                  overlay.setAttribute('aria-hidden', 'true');
                  
                  // Reset all content sections to hidden state
                  projectContent.style.display = 'none';
                  bioContent.style.display = 'none';
                  const bentoContent = document.getElementById('bento-content');
                  if (bentoContent) {
                    bentoContent.style.display = 'none';
                    // Hide all individual bento projects and reset animations
                    const allBentoProjects = bentoContent.querySelectorAll('.bento-project');
                    allBentoProjects.forEach(bp => {
                      bp.style.display = 'none';
                    });
                    // Reset bento card animations for next time
                    if (typeof window.resetBentoCards === 'function') {
                      window.resetBentoCards();
                    }
                  }
                  
                  
                  if (currentElectron && window.orbitSystem) { window.orbitSystem.resumeElectron(currentElectron); currentElectron = null; }
                  resumeLabelRotation();
                  if (lastFocused) { try { lastFocused.focus({ preventScroll: true }); } catch {} }
                  try { history.replaceState(null, '', '/'); } catch {}
                }
              });
            }

            closeBtn?.addEventListener('click', () => closeOverlay());
            window.addEventListener('popstate', (e) => {
              // If overlay is open and we popped back, close it
              if (overlayOpen && !e.state?.overlay) {
                closeOverlay();
              }
            });
            document.addEventListener('keydown', (e) => {
              if (overlayOpen && e.key === 'Escape') {
                closeOverlay();
              }
            });
            // (Backdrop click and deep-link auto-open were removed per request)

                // Add hover effects to electrons (includes shell effects)
                const allElectrons = document.querySelectorAll('.electron'); // includes nucleus
                const electrons = document.querySelectorAll('.electron:not(.nucleus)'); // exclude nucleus from drag
                const shells = document.querySelectorAll('.shell');
                let dragLock = false; // Suppress hover logic while dragging
                const micro = atomConfig.micro || {};
                const svgNS = 'http://www.w3.org/2000/svg';
				
				// IMMEDIATE STATE MANAGER - No timeouts, no race conditions
				const hoverStateManager = {
					currentState: 'none', // 'none' | 'shell-N' | electron reference
					previousState: 'none',
					currentElectron: null, // Store actual electron element reference
					previewElement: null, // Lazy-loaded
					previewActive: false, // Track if preview should be shown
					
					setState(newState, electronElement = null) {
						if (this.currentState === newState) return; // No change needed
						
						// console.log(`ð¯ STATE CHANGE: ${this.currentState} â ${newState}`);
						this.previousState = this.currentState;
						this.currentState = newState;
						this.currentElectron = electronElement;
						this.applyStateChange();
					},
					
              applyStateChange() {
                // Immediately apply all visual changes
                this.exitPreviousState();
                this.enterCurrentState();
              },
					
              exitPreviousState() {
                if (this.previousState === 'none') return;
                
                // KILL ALL EXISTING ANIMATIONS IMMEDIATELY
                gsap.killTweensOf(shells);
                // Do not kill electron tweens; rely on overwrite for smooth transitions
                
                if (this.previousState.startsWith('shell-')) {
                  const shellIndex = parseInt(this.previousState.split('-')[1]);
                  this.resetShellEffects(shellIndex);
                  // Don't hide preview if we're going to another electron state
                  if (!this.currentState.startsWith('electron-')) {
                    this.previewActive = false;
                    this.hidePreview();
                  }
                } else if (this.previousState.startsWith('electron-')) {
                  const shellIndex = parseInt(this.previousState.split('-')[1]);
                  this.resetElectronEffects(shellIndex);
                }
              },
              
              enterCurrentState() {
              if (this.currentState === 'none') {
                // Hide preview immediately for 'none' state
                this.previewActive = false;
                this.hidePreview();
                // Reset opacity for all; radius only for non-nucleus electrons
                gsap.to(document.querySelectorAll('.electron'), {
                  opacity: 1.0,
                  duration: atomConfig.timing.baselineResetDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                gsap.to(document.querySelectorAll('.electron:not(.nucleus)'), {
                  attr: { r: atomConfig.electrons.radius },
                  duration: atomConfig.timing.baselineResetDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                // Reset labels to idle
                if (atomConfig.labels?.enabled) {
                  const allLabelTexts = document.querySelectorAll('.shell-label-rotor text');
                  gsap.to(allLabelTexts, {
                    opacity: atomConfig.labels?.idleOpacity ?? 0.35,
                    duration: atomConfig.timing.baselineResetDuration,
                    ease: 'power2.out',
                    overwrite: 'auto'
                  });
                }
                return;
              }
                
                if (this.currentState.startsWith('shell-')) {
                  const shellIndex = parseInt(this.currentState.split('-')[1]);
                  // Ensure electrons are at baseline when only shell is hovered
                  // Reset opacity for all; radius only for non-nucleus electrons
                  gsap.to(document.querySelectorAll('.electron'), {
                    opacity: 1.0,
                    duration: atomConfig.timing.hoverDuration,
                    ease: 'power2.out',
                    overwrite: 'auto'
                  });
                  gsap.to(document.querySelectorAll('.electron:not(.nucleus)'), {
                    attr: { r: atomConfig.electrons.radius },
                    duration: atomConfig.timing.hoverDuration,
                    ease: 'power2.out',
                    overwrite: 'auto'
                  });
                  this.applyShellEffects(shellIndex);
                  // Brighten label for this shell
                  if (atomConfig.labels?.enabled) {
                    const rotor = document.querySelector(`.shell-label-rotor[data-shell-index="${shellIndex}"]`);
                    if (rotor) {
                      gsap.to(rotor.querySelectorAll('text'), {
                        opacity: atomConfig.labels?.hoverOpacity ?? 0.7,
                        duration: atomConfig.timing.hoverDuration,
                        ease: 'power2.out',
                        overwrite: 'auto'
                      });
                    }
                  }
                } else if (this.currentState.startsWith('electron-')) {
                  const shellIndex = parseInt(this.currentState.split('-')[1]);
                  this.applyElectronEffects(shellIndex, this.currentElectron);
                  // Show preview for electron hover (with state tracking)
                  this.previewActive = true;
                  this.showPreview(this.currentElectron);
                  // Brighten label for this shell
                  if (atomConfig.labels?.enabled) {
                    const rotor = document.querySelector(`.shell-label-rotor[data-shell-index="${shellIndex}"]`);
                    if (rotor) {
                      gsap.to(rotor.querySelectorAll('text'), {
                        opacity: atomConfig.labels?.hoverOpacity ?? 0.7,
                        duration: atomConfig.timing.hoverDuration,
                        ease: 'power2.out',
                        overwrite: 'auto'
                      });
                    }
                  }
                }
              },
					
              applyShellEffects(shellIndex) {
                const shell = shells[shellIndex];
                const shellConfig = cfg.shells[shellIndex];
                if (!shell || !shellConfig) return;
                
                // console.log(`ð¡ Applying shell ${shellIndex} effects`);
                gsap.to(shell, {
                  attr: { 'stroke-width': shellConfig.hoverStrokeWidth },
                  opacity: shellConfig.hoverOpacity,
                  duration: atomConfig.timing.hoverDuration, // Configurable
                  ease: 'power2.out'
                });
              },
					
              applyElectronEffects(shellIndex, electron) {
                const shell = shells[shellIndex];
                const shellConfig = cfg.shells[shellIndex];
                if (!shell || !shellConfig || !electron) return;
                
                // console.log(`ð´ Applying electron effects for shell ${shellIndex}`);
                
                // Apply shell effects
                this.applyShellEffects(shellIndex);
                
                // Electron growth
                gsap.to(electron, {
                  attr: { r: atomConfig.electrons.hoverRadius },
                  duration: atomConfig.timing.hoverDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                
                // Motion pause
                if (window.orbitSystem) window.orbitSystem.pauseShell(shellIndex);
                try { const t = labelTweenByShell.get(shellIndex); t && t.pause(); } catch {}
                
                // Global spotlight
                const allElectrons = document.querySelectorAll('.electron');
                allElectrons.forEach(e => {
                  if (e === electron) {
                    gsap.to(e, { opacity: 1.0, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
                  } else {
                    gsap.to(e, { opacity: shellConfig.electronHoverOpacity, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
                  }
                });
              },
					
              resetShellEffects(shellIndex) {
                const shell = shells[shellIndex];
                const shellConfig = cfg.shells[shellIndex];
                if (!shell || !shellConfig) return;
                
                // console.log(`ð Resetting shell ${shellIndex} effects`);
                gsap.to(shell, {
                  attr: { 'stroke-width': shellConfig.strokeWidth },
                  opacity: shellConfig.defaultOpacity,
                  duration: atomConfig.timing.hoverDuration,
                  ease: 'power2.out'
                });
                // Dim label back to idle
                if (atomConfig.labels?.enabled) {
                  const rotor = document.querySelector(`.shell-label-rotor[data-shell-index="${shellIndex}"]`);
                  if (rotor) {
                    gsap.to(rotor.querySelectorAll('text'), {
                      opacity: atomConfig.labels?.idleOpacity ?? 0.35,
                      duration: atomConfig.timing.hoverDuration,
                      ease: 'power2.out',
                      overwrite: 'auto'
                    });
                  }
                }
              },
					
              resetElectronEffects(shellIndex) {
                // console.log(`ð Resetting electron effects for shell ${shellIndex}`);
                
                // Hide preview (will be overridden immediately if going to another electron)
                this.previewActive = false;
                this.hidePreview();
                
                // Reset shell
                this.resetShellEffects(shellIndex);
                
                // Resume motion
                if (window.orbitSystem) window.orbitSystem.resumeShell(shellIndex);
                try {
                  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                  if (!(prefersReduced && atomConfig.motion?.respectReducedMotion)) {
                    const t = labelTweenByShell.get(shellIndex); t && t.resume();
                  }
                } catch {}
                
                // Reset all electrons
                // Opacity reset for all
                gsap.to(document.querySelectorAll('.electron'), {
                  opacity: 1.0,
                  duration: atomConfig.timing.hoverDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                // Radius reset only for non-nucleus electrons
                gsap.to(document.querySelectorAll('.electron:not(.nucleus)'), {
                  attr: { r: atomConfig.electrons.radius },
                  duration: atomConfig.timing.hoverDuration,
                  ease: 'power2.out',
                  overwrite: 'auto'
                });
                // Reset label to idle
                if (atomConfig.labels?.enabled) {
                  const rotor = document.querySelector(`.shell-label-rotor[data-shell-index="${shellIndex}"]`);
                  if (rotor) {
                    gsap.to(rotor.querySelectorAll('text'), {
                      opacity: atomConfig.labels?.idleOpacity ?? 0.35,
                      duration: atomConfig.timing.hoverDuration,
                      ease: 'power2.out',
                      overwrite: 'auto'
                    });
                  }
                }
              },
              
              // PREVIEW SYSTEM
              showPreview(electron) {
                if (!cfg.electronPreview?.enabled || !electron || !this.previewActive) return;
                
                // Lazy-load preview element
                if (!this.previewElement) {
                  this.previewElement = document.getElementById('electron-preview');
                }
                if (!this.previewElement) return;
                
                // Get project data for this electron
                const project = this.getProjectForElectron(electron);
                if (!project) return;
                
                // Populate preview content
                const img = document.getElementById('preview-image');
                const title = document.getElementById('preview-title');
                const subtitle = document.getElementById('preview-subtitle');
                
                if (img) img.src = project.preview.heroImage;
                if (title) title.textContent = project.altTitle || project.title;
                if (subtitle) subtitle.textContent = project.preview.subtitle;
                
                // Position preview (configurable offset from electron with viewport edge detection)
                const electronRect = electron.getBoundingClientRect();
                const previewWidth = cfg.electronPreview.width;
                const previewHeight = cfg.electronPreview.height;
                const offsetX = cfg.electronPreview.offsetX;
                const offsetY = cfg.electronPreview.offsetY;
                
                let x = electronRect.right + offsetX;
                let y = electronRect.top + offsetY;
                
                // Check right edge of viewport
                if (x + previewWidth > window.innerWidth) {
                  x = electronRect.left - previewWidth - offsetX;
                }
                
                // Check top edge of viewport
                if (y < 0) {
                  y = electronRect.bottom - offsetY;
                }
                
                // Apply position
                this.previewElement.style.left = x + 'px';
                this.previewElement.style.top = y + 'px';
                this.previewElement.style.display = 'flex';
                
                // Add responsive classes based on height
                this.previewElement.className = 'electron-preview';
                if (cfg.electronPreview.height < 80) {
                  this.previewElement.classList.add('preview-compact');
                } else if (cfg.electronPreview.height < 100) {
                  this.previewElement.classList.add('preview-small');
                }
                
                // Kill any existing preview animations to prevent conflicts
                gsap.killTweensOf(this.previewElement);
                
                // Calculate electron center position relative to preview's final position
                const electronCenterX = electronRect.left + electronRect.width / 2;
                const electronCenterY = electronRect.top + electronRect.height / 2;
                const previewCenterX = x + previewWidth / 2;
                const previewCenterY = y + previewHeight / 2;
                
                // Calculate offset needed to start at electron center
                const startOffsetX = electronCenterX - previewCenterX;
                const startOffsetY = electronCenterY - previewCenterY;
                
                // Set transform-origin to center for multi-stage scaling
                this.previewElement.style.transformOrigin = 'center center';
                
                // Multi-stage animation: birth â travel â expand (configurable)
                const timeline = gsap.timeline();
                const multiStage = cfg.electronPreview.multiStage || {};
                
                // Stage 1: Birth at electron center
                timeline.fromTo(this.previewElement, 
                  { 
                    scale: multiStage.birthScale || 0.1, 
                    opacity: multiStage.birthOpacity || 0.3,
                    x: startOffsetX,
                    y: startOffsetY
                  },
                  { 
                    scale: multiStage.travelScale || 0.3, 
                    opacity: multiStage.travelOpacity || 0.7,
                    x: startOffsetX * 0.7, // Start moving toward final position
                    y: startOffsetY * 0.7,
                    duration: cfg.electronPreview.animationDuration * (multiStage.stage1Duration || 0.3), 
                    ease: 'power2.out'
                  }
                )
                
                // Stage 2: Travel to final position while growing
                .to(this.previewElement, {
                  scale: multiStage.preExpandScale || 0.8,
                  opacity: multiStage.preExpandOpacity || 0.9,
                  x: 0, // Final position (no offset)
                  y: 0,
                  duration: cfg.electronPreview.animationDuration * (multiStage.stage2Duration || 0.4),
                  ease: 'power2.inOut'
                })
                
                // Stage 3: Final expansion with overshoot
                .to(this.previewElement, {
                  scale: multiStage.overshootScale || 1.05,
                  opacity: multiStage.finalOpacity || 1,
                  duration: cfg.electronPreview.animationDuration * (multiStage.stage3Duration || 0.2),
                  ease: 'back.out(2)'
                })
                
                // Settle to final scale
                .to(this.previewElement, {
                  scale: multiStage.finalScale || 1,
                  duration: cfg.electronPreview.animationDuration * (multiStage.settleDebounce || 0.1),
                  ease: 'power2.out'
                });
              },
              
              hidePreview() {
                if (!this.previewElement) {
                  this.previewElement = document.getElementById('electron-preview');
                }
                if (!this.previewElement) return;
                
                // Kill any existing animations
                gsap.killTweensOf(this.previewElement);
                
                gsap.to(this.previewElement, {
                  scale: 0.8,
                  opacity: 0,
                  duration: 0.15,
                  ease: 'power2.in',
                  onComplete: () => {
                    this.previewElement.style.display = 'none';
                  }
                });
              },
              
              scaleDownPreview() {
                if (!this.previewElement) {
                  this.previewElement = document.getElementById('electron-preview');
                }
                if (!this.previewElement || !this.previewActive) return;
                
                // Kill any existing animations
                gsap.killTweensOf(this.previewElement);
                
                // Scale down quickly to avoid overlap with opening animation
                gsap.to(this.previewElement, {
                  scale: 0.3,
                  opacity: 0.2,
                  duration: 0.2,
                  ease: 'power2.in',
                  onComplete: () => {
                    this.previewElement.style.display = 'none';
                    this.previewActive = false;
                  }
                });
              },
              
              getProjectForElectron(electron) {
                // Extract shell and electron indices from the electron's attributes
                const shellIndex = parseInt(electron.getAttribute('data-shell-index') || '0');
                const electronIndex = parseInt(electron.getAttribute('data-electron-index') || '0');
                
                // Find the project from PROJECTS data using shell/electron indices
                // Projects are organized by domain in the same order as shells
                const domainSlug = cfg.domains[shellIndex];
                const domainProjects = PROJECTS.filter(p => p.domain === domainSlug);
                
                return domainProjects[electronIndex] || null;
              }
				};
				
				
				electrons.forEach((electron, electronIndex) => {
					const shellIndex = parseInt(electron.dataset.shell);
					
                electron.addEventListener('mouseenter', () => {
                    if (dragLock) return;
                    // Record electron event timing to prevent mousemove conflicts
                    lastElectronEventTime = performance.now();
                    // Pass the actual electron element to the state manager
                    hoverStateManager.setState(`electron-${shellIndex}-${electronIndex}`, electron);
                    
                    // Pause electron orbital motion when hovering
                    if (window.orbitSystem) {
                        window.orbitSystem.pauseElectron(electron);
                    }
                    
                    // PLACEHOLDER: Play electron hover sound - replace with OGG file playback
                    // Use state key to prevent repetition during same hover
                    atomSounds.playSound('electronHover', `electron-${shellIndex}-${electronIndex}-hover`);
                    // Micro: hover ring
                    try {
                      if (micro.hoverCursorRing) {
                        const parent = electron.parentNode;
                        const baseR = parseFloat(electron.getAttribute('r')) || 0;
                        const cx = parseFloat(electron.getAttribute('cx'));
                        const cy = parseFloat(electron.getAttribute('cy'));
                        const ring = document.createElementNS(svgNS, 'circle');
                        ring.setAttribute('cx', String(cx));
                        ring.setAttribute('cy', String(cy));
                        ring.setAttribute('r', String(baseR));
                        ring.setAttribute('fill', 'none');
                        ring.setAttribute('stroke', atomConfig.electrons.color || '#000');
                        ring.setAttribute('stroke-width', '1');
                        ring.style.pointerEvents = 'none';
                        // Align with electron transforms (paused on hover)
                        const tx = parseFloat(gsap.getProperty(electron, 'x')) || 0;
                        const ty = parseFloat(gsap.getProperty(electron, 'y')) || 0;
                        gsap.set(ring, { x: tx, y: ty, opacity: 0 });
                        parent.appendChild(ring);
                        // Animate outwards and hold
                        gsap.to(ring, {
                          attr: { r: baseR + (micro.hoverRingDelta ?? 6) },
                          opacity: micro.hoverRingOpacity ?? 0.6,
                          duration: (micro.hoverRingDurationMs ?? 160) / 1000,
                          ease: 'power2.out'
                        });
                        // Store ref for removal on leave
                        electron._hoverRing = ring;
                      }
                    } catch {}
                });
					
                electron.addEventListener('mouseleave', () => {
                    if (dragLock) return;
                    
                    // Resume electron orbital motion when leaving
                    if (window.orbitSystem) {
                        window.orbitSystem.resumeElectron(electron);
                    }
                    
                    // Reset sound state when leaving electron
                    atomSounds.lastSoundState = null;
                    // Check if we're still in the shell's tolerance zone via distance calculation
                    // The mousemove handler will determine the correct next state
                    // For now, assume we're leaving completely (will be corrected by mousemove if needed)
                    hoverStateManager.setState('none');
                    // Micro: remove hover ring
                    try {
                      const ring = electron._hoverRing;
                      if (ring) {
                        gsap.to(ring, { opacity: 0, duration: 0.12, onComplete: () => { try { ring.remove(); } catch {} } });
                        electron._hoverRing = null;
                      }
                    } catch {}
                });

					// Minimal drag-and-drop (no tether visuals)
					let pressTime = 0;
					let maxTravel = 0;
					let startX = 0, startY = 0;
					Draggable.create(electron, {
						type: 'x,y',
						onPress: function () {
							dragLock = true;
							pressTime = performance.now();
							startX = parseFloat(gsap.getProperty(electron, 'x')) || 0;
							startY = parseFloat(gsap.getProperty(electron, 'y')) || 0;
							maxTravel = 0;
							// Pause only this electron's motion
							if (window.orbitSystem) window.orbitSystem.pauseElectron(electron);
							
							// PLACEHOLDER: Start creative drag sequence - replace with OGG files
							const electronId = `${shellIndex}-${electronIndex}`;
							atomSounds.startDragSequence(electronId);
						},
						onDrag: function () {
							const curX = parseFloat(gsap.getProperty(electron, 'x')) || 0;
							const curY = parseFloat(gsap.getProperty(electron, 'y')) || 0;
							const dx = curX - startX;
							const dy = curY - startY;
							const dist = Math.hypot(dx, dy);
							maxTravel = Math.max(maxTravel, dist);
						},
						onRelease: function () {
							const releaseTime = performance.now();
							const clickThresholdPx = 8;
							const clickThresholdMs = 180;
							const isClick = maxTravel < clickThresholdPx && (releaseTime - pressTime) < clickThresholdMs;
                    const snapBack = () => {
                        // PLACEHOLDER: Stop drag sequence with snap back sound - replace with OGG file playback
                        atomSounds.stopDragSequence(true); // Snap back
                        
                        const amp = atomConfig.timing.dragElastic?.amplitude ?? 0.8;
                        const per = atomConfig.timing.dragElastic?.period ?? 0.25;
                        const elasticEase = `elastic.out(${amp}, ${per})`;
                        gsap.to(electron, {
                            x: startX,
                            y: startY,
                            duration: atomConfig.timing.dragSnapDuration ?? atomConfig.timing.hoverDuration,
                            ease: elasticEase,
                            onComplete: () => {
                                if (window.orbitSystem) window.orbitSystem.resumeElectron(electron);
                                setTimeout(() => { dragLock = false; }, 80);
                            }
                        });
                    };
                    if (isClick) {
                        // PLACEHOLDER: Stop drag sequence - this was a click, not a drag
                        atomSounds.stopDragSequence(false); // No snap back for click
                        
                        const rect = electron.getBoundingClientRect();
                        const cx = rect.left + rect.width / 2;
                        const cy = rect.top + rect.height / 2;
                        const slug = electron.getAttribute('data-project');
                        // Micro: ripple and shell pulse
                        try {
                          if (micro.ripple) {
                            // PLACEHOLDER: Play ripple sound - replace with OGG file playback
                            atomSounds.playSound('ripple');
                            const parent = electron.parentNode;
                            const baseR = parseFloat(electron.getAttribute('r')) || 0;
                            const cxAttr = parseFloat(electron.getAttribute('cx'));
                            const cyAttr = parseFloat(electron.getAttribute('cy'));
                            const ripple = document.createElementNS(svgNS, 'circle');
                            ripple.setAttribute('cx', String(cxAttr));
                            ripple.setAttribute('cy', String(cyAttr));
                            ripple.setAttribute('r', String(baseR));
                            ripple.setAttribute('fill', 'none');
                            ripple.setAttribute('stroke', micro.rippleColor || '#000');
                            ripple.setAttribute('stroke-width', String(micro.rippleStrokeWidth ?? 2));
                            ripple.style.pointerEvents = 'none';
                            const tx = parseFloat(gsap.getProperty(electron, 'x')) || 0;
                            const ty = parseFloat(gsap.getProperty(electron, 'y')) || 0;
                            gsap.set(ripple, { x: tx, y: ty, opacity: 0.8 });
                            parent.appendChild(ripple);
                            gsap.to(ripple, {
                              attr: { r: baseR + (micro.rippleExpandPx ?? 56) },
                              opacity: 0,
                              duration: (micro.rippleDurationMs ?? 360) / 1000,
                              ease: 'power2.out',
                              onComplete: () => { try { ripple.remove(); } catch {} }
                            });
                          }
                          if (micro.shellPulse) {
                            // PLACEHOLDER: Play shell pulse sound - replace with OGG file playback
                            atomSounds.playSound('shellPulse');
                            const shell = shells[shellIndex];
                            if (shell) {
                              const curW = parseFloat(shell.getAttribute('stroke-width')) || 0;
                              const target = curW + (micro.shellPulseDelta ?? 1.2);
                              gsap.to(shell, {
                                attr: { 'stroke-width': target },
                                duration: (micro.shellPulseDurationMs ?? 200) / 1000 / 2,
                                ease: 'power2.out',
                                yoyo: true,
                                repeat: 1
                              });
                            }
                          }
                          // Remove hover ring if present
                          if (electron._hoverRing) {
                            const ring = electron._hoverRing; electron._hoverRing = null;
                            gsap.to(ring, { opacity: 0, duration: 0.1, onComplete: () => { try { ring.remove(); } catch {} } });
                          }
                        } catch {}
                        
                        // Scale down preview before opening overlay to prevent overlap
                        hoverStateManager.scaleDownPreview();
                        
                        // PLACEHOLDER: Play electron click sound - replace with OGG file playback
                        atomSounds.playSound('electronClick');
                        openProjectOverlay(slug, cx, cy, electron);
                        setTimeout(() => { dragLock = false; }, 80);
                    } else {
                        // Drag release: snap back
                        snapBack();
                    }
						}
					});

					// Add keyboard support for electrons
					electron.addEventListener('keydown', (e) => {
						if (e.key === 'Enter' || e.key === ' ') {
							e.preventDefault();
							// Simulate click behavior
							const rect = electron.getBoundingClientRect();
							const cx = rect.left + rect.width / 2;
							const cy = rect.top + rect.height / 2;
							
							const slug = electron.getAttribute('data-project');
							if (slug) {
								hoverStateManager.scaleDownPreview();
								atomSounds.playSound('electronClick');
								openProjectOverlay(slug, cx, cy, electron);
							}
						}
					});
				});

				// Add focus management for keyboard navigation
				const focusableElements = document.querySelectorAll('[tabindex="0"]');
				focusableElements.forEach((element, index) => {
					element.addEventListener('keydown', (e) => {
						if (e.key === 'Tab') {
							// Let browser handle normal tab navigation
							return;
						}
						
						if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
							e.preventDefault();
							const prevIndex = (index - 1 + focusableElements.length) % focusableElements.length;
							focusableElements[prevIndex].focus();
						} else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
							e.preventDefault();
							const nextIndex = (index + 1) % focusableElements.length;
							focusableElements[nextIndex].focus();
						}
					});
				});

				// Nucleus hover: grow + global spotlight; click placeholder
				const nucleus = document.getElementById('nucleus-circle');
				if (nucleus) {
					nucleus.addEventListener('mouseenter', () => {
						if (dragLock) return;
						
						// PLACEHOLDER: Play nucleus hover sound - replace with OGG file playback
						// Use state key to prevent repetition during same hover
						atomSounds.playSound('nucleusHover', 'nucleus-hover');
						gsap.to(nucleus, {
							attr: { r: atomConfig.nucleus.hoverRadius },
							duration: atomConfig.timing.hoverDuration,
							ease: 'power2.out',
							overwrite: 'auto'
						});
                const dimOpacity = cfg.shells[0]?.electronHoverOpacity ?? 0.2;
						allElectrons.forEach(e => {
							if (e === nucleus) {
								gsap.to(e, { opacity: 1.0, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
							} else {
								gsap.to(e, { opacity: dimOpacity, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
							}
						});
					});
					nucleus.addEventListener('mouseleave', () => {
						// Reset sound state when leaving nucleus
						atomSounds.lastSoundState = null;
						gsap.to(nucleus, {
							attr: { r: atomConfig.nucleus.radius },
							duration: atomConfig.timing.hoverDuration,
							ease: 'power2.out',
							overwrite: 'auto'
						});
						allElectrons.forEach(e => {
							gsap.to(e, { opacity: 1.0, duration: atomConfig.timing.hoverDuration, ease: 'power2.out', overwrite: 'auto' });
						});
					});
					nucleus.addEventListener('click', () => {
                // PLACEHOLDER: Play nucleus click sound - replace with OGG file playback
                atomSounds.playSound('nucleusClick');
                
                // Micro: ripple effect similar to electrons
                try {
                  if (micro.ripple) {
                    const parent = nucleus.parentNode;
                    const baseR = parseFloat(nucleus.getAttribute('r')) || 0;
                    const cxAttr = parseFloat(nucleus.getAttribute('cx'));
                    const cyAttr = parseFloat(nucleus.getAttribute('cy'));
                    const ripple = document.createElementNS(svgNS, 'circle');
                    ripple.setAttribute('cx', String(cxAttr));
                    ripple.setAttribute('cy', String(cyAttr));
                    ripple.setAttribute('r', String(baseR));
                    ripple.setAttribute('fill', 'none');
                    ripple.setAttribute('stroke', micro.rippleColor || '#000');
                    ripple.setAttribute('stroke-width', String(micro.rippleStrokeWidth ?? 2));
                    ripple.style.pointerEvents = 'none';
                    const tx = parseFloat(gsap.getProperty(nucleus, 'x')) || 0;
                    const ty = parseFloat(gsap.getProperty(nucleus, 'y')) || 0;
                    gsap.set(ripple, { x: tx, y: ty, opacity: 0.8 });
                    parent.appendChild(ripple);
                    gsap.to(ripple, {
                      attr: { r: baseR + (micro.rippleExpandPx ?? 56) },
                      opacity: 0,
                      duration: (micro.rippleDurationMs ?? 360) / 1000,
                      ease: 'power2.out',
                      onComplete: () => { try { ripple.remove(); } catch {} }
                    });
                  }
                } catch {}
                const rect = nucleus.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                openBioOverlay(cx, cy);
              });

              // Add keyboard support for nucleus
              nucleus.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  e.preventDefault();
                  nucleus.click();
                }
              });
				}
				
				// RAF-THROTTLED HITBOX SYSTEM - Optimized for performance
      const svgContainer = document.getElementById('atom-svg');
      const tolerance = atomConfig.hitbox?.tolerance ?? 15; // pixels - configurable via user-tweaks.js
				
				// Pre-calculate shell boundaries for performance (squared distances avoid Math.sqrt)
				const shellBoundaries = cfg.shells.map((shell, shellIndex) => ({
					innerBoundSquared: (shell.radius - tolerance) ** 2,
					outerBoundSquared: (shell.radius + tolerance) ** 2,
					shellIndex: shellIndex
				}));
				
				// RAF throttling variables
				let rafId = null;
				let pendingMousePosition = null;
				let lastElectronEventTime = 0;
				
				// Capture mouse position (high frequency)
				svgContainer.addEventListener('mousemove', (e) => {
					const rect = svgContainer.getBoundingClientRect();
					// Store only the LATEST mouse position (client coords)
					pendingMousePosition = { clientX: e.clientX, clientY: e.clientY, rectLeft: rect.left, rectTop: rect.top, rectWidth: rect.width, rectHeight: rect.height };
					
					// Schedule processing if not already scheduled (throttled to 60fps)
					if (!rafId) {
						rafId = requestAnimationFrame(processMousePosition);
					}
				});
				
				// Process mouse position (60fps max)
				function processMousePosition() {
					if (!pendingMousePosition) {
						rafId = null;
						return;
					}
					
					// Skip hover processing while dragging
					if (dragLock) {
						pendingMousePosition = null;
						rafId = null;
						return;
					}
					
					const rect = svgContainer.getBoundingClientRect();
					const viewW = baseW;
					const viewH = baseH;
					const scaleX = viewW / rect.width;
					const scaleY = viewH / rect.height;
					const mouseX = (pendingMousePosition.clientX - rect.left) * scaleX;
					const mouseY = (pendingMousePosition.clientY - rect.top) * scaleY;
					const centerX = viewW / 2;
					const centerY = viewH / 2;
					
					// Calculate SQUARED distance (faster - no Math.sqrt needed)
					const distanceSquared = (mouseX - centerX) ** 2 + (mouseY - centerY) ** 2;
					
					// Check which shell we're hovering (if any) using squared distances
					let hoveredShellIndex = null;
					for (let boundary of shellBoundaries) {
						if (distanceSquared >= boundary.innerBoundSquared && 
							distanceSquared <= boundary.outerBoundSquared) {
							hoveredShellIndex = boundary.shellIndex;
							// console.log(`ð¯ HITBOX: Mouse in shell ${hoveredShellIndex} tolerance zone`);
							break; // Exit early when found
						}
					}
					
					// IMMEDIATE STATE CHANGES - No timeouts, no race conditions
					// Check if we should defer to recent electron events (prevents conflicts)
					const timeSinceElectronEvent = performance.now() - lastElectronEventTime;
					const shouldDeferToElectronEvent = timeSinceElectronEvent < 100; // 100ms grace period
					
					if (hoveredShellIndex !== null) {
						// Only update if we're not already in an electron state for this shell
						const currentElectronState = hoverStateManager.currentState.startsWith(`electron-${hoveredShellIndex}-`);
						if (!currentElectronState && !shouldDeferToElectronEvent) {
							hoverStateManager.setState(`shell-${hoveredShellIndex}`);
							
							// PLACEHOLDER: Play shell hover sound - replace with OGG file playback
							// Use state key to prevent repetition during same hover
							atomSounds.playSound('shellHover', `shell-${hoveredShellIndex}-hover`);
						}
					} else {
						// Not hovering any shell - go to none state (but respect recent electron events)
						if (!shouldDeferToElectronEvent) {
							hoverStateManager.setState('none');
							// Reset sound state when leaving all shells
							atomSounds.lastSoundState = null;
						}
					}
					
					// Clear for next frame
					pendingMousePosition = null;
					rafId = null;
				}
				
				// Reference already stored globally above
				
				// console.log('ð PHASE 1+2 COMPLETE: Immediate State Manager + RAF Throttling');
				// console.log(`Found ${electrons.length} electrons and ${shells.length} visual shells`);
				// console.log(`ð® Optimized hitbox system: Â±${tolerance}px zones, 60fps max, squared distances`);
				// console.log('ð¯ Features: Animation interruption, no timeouts, no race conditions');
				
				// Focus-visible polyfill for better keyboard navigation UX
				setupFocusVisible();
			});
			
			// Focus-visible polyfill - only show focus when using keyboard navigation
			function setupFocusVisible() {
				let hadKeyboardEvent = true;
				const keyboardThrottleTimeout = 100;
				
				const focusableElements = document.querySelectorAll('.electron, .nucleus');
				
				function onPointerDown() {
					hadKeyboardEvent = false;
				}
				
				function onKeyDown(e) {
					if (e.metaKey || e.altKey || e.ctrlKey) return;
					hadKeyboardEvent = true;
				}
				
				function onFocus(e) {
					if (hadKeyboardEvent || e.target.matches(':focus-visible')) {
						e.target.classList.add('focus-visible');
					} else {
						e.target.classList.remove('focus-visible');
					}
				}
				
				function onBlur(e) {
					e.target.classList.remove('focus-visible');
				}
				
				// Add event listeners
				document.addEventListener('keydown', onKeyDown, true);
				document.addEventListener('mousedown', onPointerDown, true);
				document.addEventListener('touchstart', onPointerDown, true);
				
				focusableElements.forEach(element => {
					element.addEventListener('focus', onFocus, true);
					element.addEventListener('blur', onBlur, true);
				});
			}
		</script>

		<!-- Performance Monitoring and Error Tracking -->
		<script type="module">
			import monitor from '../utils/monitoring.js';

			// Track GSAP animation events
			document.addEventListener('DOMContentLoaded', () => {
				const originalSet = gsap.set;
				const originalTo = gsap.to;

				// Track animation starts and completions
				gsap.set = function(...args) {
					monitor.track('gsap_set', { timestamp: performance.now() });
					return originalSet.apply(this, args);
				};

				gsap.to = function(target, vars) {
					monitor.track('gsap_animation_start', { 
						timestamp: performance.now(),
						target: target?.constructor?.name || 'unknown',
						duration: vars.duration 
					});
					
					const originalOnComplete = vars.onComplete;
					vars.onComplete = function(...args) {
						monitor.track('gsap_animation_complete', { 
							timestamp: performance.now(),
							duration: vars.duration 
						});
						if (originalOnComplete) originalOnComplete.apply(this, args);
					};

					return originalTo.apply(this, arguments);
				};

				// Track orbital system performance
				if (window.orbitSystem) {
					const originalStart = window.orbitSystem.start;
					const originalStop = window.orbitSystem.stop;

					window.orbitSystem.start = function(...args) {
						monitor.track('orbit_system_start', { timestamp: performance.now() });
						return originalStart.apply(this, args);
					};

					window.orbitSystem.stop = function(...args) {
						monitor.track('orbit_system_stop', { timestamp: performance.now() });
						return originalStop.apply(this, args);
					};
				}

				// Track electron interactions
				document.addEventListener('click', (e) => {
					if (e.target.classList.contains('electron')) {
						monitor.track('electron_click', {
							timestamp: performance.now(),
							electronType: e.target.classList.contains('nucleus') ? 'nucleus' : 'electron',
							shell: e.target.dataset?.shell
						});
					}
				});

				// Debug console commands
				// console.log('ð Performance monitoring active. Debug commands:');
				// console.log('  window.performanceMonitor.enable() - Force enable monitoring');
				// console.log('  window.performanceMonitor.getMetrics() - View collected metrics');
				// console.log('  window.performanceMonitor.getErrors() - View error log');
			});
		</script>

		<!-- Service Worker Registration -->
		<script>
			// Register service worker for PWA capabilities and caching
			if ('serviceWorker' in navigator) {
				window.addEventListener('load', () => {
					navigator.serviceWorker.register('/sw.js')
						.then((registration) => {
							// console.log('ð Service Worker registered:', registration.scope);
							
							// Listen for updates
							registration.addEventListener('updatefound', () => {
								const newWorker = registration.installing;
								if (newWorker) {
									newWorker.addEventListener('statechange', () => {
										if (newWorker.state === 'activated') {
											// console.log('â Service Worker updated');
											// Optionally notify user of updates
										}
									});
								}
							});
						})
						.catch((error) => {
							// console.warn('â Service Worker registration failed:', error);
						});
				});
			}
		</script>
	</body>
</html>
